    
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8" />
    <title>Flappy Chico</title>
    <style>
        body {
            background: linear-gradient(to bottom, #87ceeb 0%, #f0e68c 100%);
            margin: 0;
            overflow: hidden;
            font-family: 'Treasure Map Deadhand', Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
            margin: 40px auto 0 auto;
            background: #87ceeb;
            border: 4px solid #222;
            box-shadow: 0 0 20px #222;
            /* Mobile friendly */
            touch-action: manipulation;
            -ms-touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            padding: 6px 18px;
            background: rgba(0,0,0,0.25);
            border: 2px solid rgba(255,255,255,0.25);
            border-radius: 14px;
            backdrop-filter: blur(6px) saturate(140%);
        }
        #muteBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            border: 2px solid #222;
            background: rgba(0,0,0,0.45);
            color: #fff;
            font-size: 18px;
            line-height: 1;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            text-shadow: 1px 1px 2px #000;
        }
    #muteBtn:active { transform: scale(0.98); }
        .diffPanel h1 {
            font-size: 40px;
            margin: 0 0 12px;
            letter-spacing: 1px;
            text-shadow: 0 4px 10px rgba(0,0,0,0.6);
        }
        .diffPanel p.subtitle {
            margin: 0 0 18px;
            font-size: 16px;
            letter-spacing: 0.5px;
            opacity: 0.9;
        }
        .diffButtons { display: flex; gap: 14px; justify-content: center; margin-bottom: 14px; flex-wrap: wrap; }
        .diffButtons button {
            flex: 1 1 90px;
            background: linear-gradient(160deg, #ffcc47, #ff8c00);
            border: none;
            border-radius: 18px;
            padding: 14px 8px 12px;
            color: #222;
            font-weight: 700;
            font-size: 15px;
            letter-spacing: 0.5px;
            cursor: pointer;
            position: relative;
            box-shadow: 0 4px 14px -4px rgba(0,0,0,0.6);
            transition: transform .18s, box-shadow .18s, background .4s;
        }
        .diffButtons button span.small {
            display: block;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.3px;
            opacity: 0.75;
            margin-top: 4px;
        }
        .diffButtons button.easy { background: linear-gradient(150deg,#7dffa0,#12d65b); }
        .diffButtons button.normal { background: linear-gradient(150deg,#51c6ff,#0066ff); color: #fff; }
        .diffButtons button.hard { background: linear-gradient(150deg,#ff5f89,#d4002f); color: #fff; }
        .diffButtons button:hover { transform: translateY(-4px); box-shadow: 0 10px 22px -10px rgba(0,0,0,0.9); }
        .diffButtons button:active { transform: translateY(1px); }
        .diffButtons button.active { outline: 3px solid rgba(255,255,255,0.9); }
        .diffInfo {
            font-size: 12px;
            line-height: 1.45;
            opacity: 0.85;
            padding: 0 8px;
            margin-top: 4px;
        }
        .tapHintInline { margin-top: 18px; font-size: 14px; opacity: 0.85; }
        @media (max-width: 480px){
            .diffPanel h1 { font-size: 32px; }
            .diffPanel { padding: 24px 20px 32px; }
            #score { font-size: 1.4em; }
        }
        #fireBtn {
            position: absolute;
            bottom: 18px;
            left: 16px;
            z-index: 12;
            width: 70px;
            height: 70px;
            border-radius: 18px;
            border: 3px solid rgba(255,255,255,0.4);
            background: radial-gradient(circle at 30% 30%, #ffe27a, #ff9f1c 65%, #cc6d00);
            color: #4b2200;
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 6px 18px -6px rgba(0,0,0,0.6), 0 0 0 3px rgba(0,0,0,0.3) inset;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.6);
            user-select: none;
            -webkit-user-select: none;
        }
        #fireBtn:active { transform: scale(.95); }
        #ammoDisplay {
            position: absolute;
            bottom: 94px;
            left: 22px;
            font-size: 22px;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 2px;
            z-index: 12;
            pointer-events: none;
        }
        /* Overlay difficolt√† centrato */
        #difficultyOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.45);
            z-index: 30;
        }
        #diffGearBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 48px;
            height: 48px;
            border-radius: 6px;
            font-size: 24px;
            line-height: 1;
            border: 2px solid #222;
            background: rgba(0,0,0,0.45);
            color: #fff;
            box-shadow: 0 0 20px #222;
            cursor: pointer;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            transition: transform .18s, box-shadow .18s;
        }
        #diffGearBtn:active { transform: scale(0.98); }
        .diffPanel {
            background: rgba(0,0,0,0.55);
            padding: 36px 44px 46px;
            border: 3px solid rgba(255,255,255,0.25);
            border-radius: 28px;
            box-shadow: 0 10px 28px -6px rgba(0,0,0,0.7), 0 0 0 4px rgba(255,255,255,0.07) inset;
            backdrop-filter: blur(10px) saturate(140%);
            max-width: 360px;
            text-align: center;
            color: #fff;
        }
        @media (max-width: 480px){
            .diffPanel { padding: 28px 24px 38px; border-radius: 24px; }
        }
    </style>
</head>
<body>
    <div id="score">RUM: 0</div>
    <div id="ammoDisplay" aria-label="Munizioni"></div>
    <button id="diffGearBtn" aria-label="Cambia difficolt√†" title="Difficolt√†">‚öôÔ∏è</button>
    <div id="difficultyOverlay" role="dialog" aria-modal="true">
        <div class="diffPanel">
            <h1>Flappy Chico</h1>
            <p class="subtitle">Scegli la difficolt√†</p>
            <div class="diffButtons" id="diffButtons">
                <button class="easy" data-diff="facile">Facile<span class="small">Gap ampio</span></button>
                <button class="normal active" data-diff="normale">Normale<span class="small">Esperienza base</span></button>
                <button class="hard" data-diff="difficile">Difficile<span class="small">Sfida!</span></button>
            </div>
            <div class="diffInfo" id="diffInfo">Normale: equilibrio tra velocit√† e spazio. Puoi cambiare prima di iniziare.</div>
            <div class="tapHintInline">Dopo aver scelto: TAP per volare</div>
        </div>
    </div>
    <button id="muteBtn" aria-label="Toggle audio" title="Audio">üîä</button>
    <button id="fireBtn" aria-label="Spara" title="Spara">üåΩ</button>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
        <!-- Overlay tutorial -->
        <div id="tutorialOverlay" style="display:none; position:fixed; z-index:1000; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.72); color:#fff; font-size:1.25em; text-align:center;">
            <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(30,30,30,0.92); border-radius:22px; padding:36px 28px 32px 28px; max-width:340px; box-shadow:0 8px 32px #000;">
                <h2 style="margin-top:0; font-size:1.6em;">Come si gioca</h2>
                <ul style="text-align:left; margin:0 0 18px 0; padding:0 0 0 18px; font-size:1em;">
                    <li><b>Tocca</b> o per volare üïäÔ∏è</li>
                    <li>Raccogli <b>bottiglie di rum</b> <span style="font-size:1.2em;">üçæ</span> per fare punti</li>
                    <li>Evita <b>barili</b> e <b>gabbiani</b> <span style="font-size:1.2em;">ü™µüê¶</span></li>
                    <li>Premi <b>üåΩ</b> per sparare ai gabbiani/barili volanti</li>
                    <li>Raccogli <b>mais</b> <span style="font-size:1.2em;">üåΩ</span> per ricaricare i colpi</li>
                    <li>Prendi lo <b>scudo</b> <span style="font-size:1.2em;">üõ°Ô∏è</span> per proteggerti da un colpo</li>
                </ul>
                <button id="closeTutorialBtn" style="margin-top:10px; font-size:1.1em; padding:8px 28px; border-radius:12px; border:none; background:#ffd700; color:#222; font-weight:bold; cursor:pointer; box-shadow:0 2px 8px #0006;">OK, inizia!</button>
            </div>
        </div>
        <script>
        // Mostra tutorial solo alla prima partita (usa localStorage)
        window.addEventListener('DOMContentLoaded', function() {
            if (!localStorage.getItem('chicoTutorialSeen')) {
                document.getElementById('tutorialOverlay').style.display = 'block';
            }
            document.getElementById('closeTutorialBtn').onclick = function() {
                document.getElementById('tutorialOverlay').style.display = 'none';
                localStorage.setItem('chicoTutorialSeen','1');
            };
        });
        // Costanti di gioco
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
    const GRAVITY_BASE = 0.33; // val base normal (ridotto)
        let gravity = GRAVITY_BASE;
    const FLAP = -5.2; // salto meno potente
        const CHICO_RADIUS = 24;
        let chicoY = canvas.height / 2;
        let chicoVY = 0;
    let score = 0;
        let gameOver = false;
        // Start & safe-start
        let hasStarted = false;
        let showHint = true;
        const SAFE_START_DURATION = 1600; // ms di invulnerabilit√† iniziale
        let safeStartEndTime = 0;

        // Ostacoli (barili)
        const OBSTACLE_WIDTH = 60;
    const OBSTACLE_GAP_DEFAULT = 320;
    const OBSTACLE_SPEED_DEFAULT = 2.4;
    // Difficolt√† dinamica (basata su difficolt√† scelta)
    let obstacleGap = OBSTACLE_GAP_DEFAULT;
    let obstacleSpeed = OBSTACLE_SPEED_DEFAULT;
    let baseObstacleGap = OBSTACLE_GAP_DEFAULT;
    let baseObstacleSpeed = OBSTACLE_SPEED_DEFAULT;
    let diffScale = 1.0; // modifica quanto la difficolt√† cresce col punteggio
    const DIFFICULTIES = {
        'facile':   { gap: 400, speed: 1.18, gravity: 0.18, dynamicScale: 0.60, desc: 'Gap molto ampio, ostacoli lenti, Chico leggero.' },
        'normale':  { gap: 340, speed: 1.55, gravity: 0.23, dynamicScale: 0.82, desc: 'Esperienza bilanciata e accessibile.' },
        'difficile':{ gap: 270, speed: 2.15, gravity: 0.29, dynamicScale: 1.08, desc: 'Gap stretto, Chico pi√π pesante, ma meno punitivo.' }
    };
    let currentDifficulty = 'normale';
    let difficultyChosen = false;
        let obstacles = [];

        // Bottiglie di rum
    const BOTTLE_RADIUS = 16;
    let bottles = [];
    // Power-up: Scudo (invincibilit√† per un colpo)
    const SHIELD_RADIUS = 18;
    let shieldItems = [];
    let hasShield = false;
    // Stato visivo / invulnerabilit√† scudo
    let shieldBreakingEnd = 0; // fine anim rottura
    let shieldInvulnUntil = 0; // invuln attiva mentre scudo integro o in rottura
    let shieldCharges = 0;
    const SHIELD_HITS = 1;
    let lastShieldSpawnScore = 0;
    const SHIELD_MIN_SCORE_GAP = 4;
    const SHIELD_SPAWN_CHANCE = 0.5; // probabilit√† per frame
    const SHIELD_BREAK_DURATION = 600; // ms animazione rottura (invulnerabile)
        // Particelle scintille
        let particles = [];
    // --- Munizioni & proiettili (chicchi di mais) ---
    const MAX_AMMO = 3;
    let ammo = MAX_AMMO;
    let projectiles = []; // {x,y,vx,vy,r}
    // Corn pickups (pannocchie)
    const CORN_RADIUS = 18;
    let cornItems = []; // {x,y,collected:false}
    let lastCornSpawnScore = 0;
    const CORN_MIN_SCORE_GAP = 5; // distanza minima in punteggio prima di poter spawnare una nuova pannocchia
    const CORN_SPAWN_CHANCE = 0.35; // probabilit√† per frame quando eleggibile
        // Parallax: navi/isole
        const parallaxElements = [
            {x: 70, y: 420, w: 90, h: 40, type: 'island'},
            {x: 320, y: 545, w: 70, h: 30, type: 'ship'} 
        ];
        // --- Nuvole di sfondo (alto) ---
        // --- Sistema nuvole migliorato (multi-layer con profondit√†, gradienti e variazioni) ---
        // Nuvole pi√π grandi, dense e scenografiche
        const CLOUD_LAYER_CONFIG = [
            { id:0, weight:0.28, speed:[0.04,0.08], scale:[0.75,1.05], alpha:0.50, y:[-35,25],   blur:7 },   // lontane, grandi (ancora pi√π in alto)
            { id:1, weight:0.48, speed:[0.09,0.16], scale:[1.05,1.35], alpha:0.80, y:[-10,60],    blur:10 },  // medie, molto grandi (ancora pi√π in alto)
            { id:2, weight:0.24, speed:[0.15,0.26], scale:[1.3,1.65], alpha:0.92, y:[10,100],    blur:14 }   // vicine, enormi (ancora pi√π in alto)
        ];
        const TOTAL_CLOUDS = 11;
        let clouds = [];
        function pickLayer() {
            const r = Math.random();
            let acc = 0;
            for (const cfg of CLOUD_LAYER_CONFIG) { acc += cfg.weight; if (r <= acc) return cfg; }
            return CLOUD_LAYER_CONFIG[CLOUD_LAYER_CONFIG.length-1];
        }
        function createCloud(x, layerCfg) {
            const cfg = layerCfg || pickLayer();
            const scale = cfg.scale[0] + Math.random() * (cfg.scale[1]-cfg.scale[0]);
            const baseW = 150, baseH = 48;
            const w = baseW * scale * (0.95 + Math.random()*0.5);
            const h = baseH * scale * (0.75 + Math.random()*0.35);
            const y = cfg.y[0] + Math.random() * (cfg.y[1]-cfg.y[0]);
            const speed = cfg.speed[0] + Math.random() * (cfg.speed[1]-cfg.speed[0]);
            const lobes = 4 + Math.floor(Math.random()*2); // 4-5
            const lobeData = [];
            const spacing = w / (lobes + 1);
            for (let i=0;i<lobes;i++) {
                const lx = -w/2 + spacing*(i+1);
                const ly = (Math.random()*0.5 - 0.25) * h * 0.35;
                const rw = spacing * (0.95 + Math.random()*0.25) * (0.85 + (i%2)*0.12);
                const rh = h * (0.28 + Math.random()*0.22);
                lobeData.push({ lx, ly, rw, rh });
            }
            return { x, y, w, h, speed, lobes, lobeData, layer: cfg.id, alpha: cfg.alpha, blur: cfg.blur, scale };
        }
        function resetClouds() {
            clouds = [];
            // Distribuisci lungo l'asse X tenendo conto della densit√†
            for (let i=0;i<TOTAL_CLOUDS;i++) {
                const cfg = pickLayer();
                const gap = 120 + Math.random()*180;
                const x = i===0 ? 0 : (clouds[i-1].x + gap);
                clouds.push(createCloud(x, cfg));
            }
        }
        function recycleCloud(c) {
            const lastX = clouds.reduce((m,cl)=> Math.max(m, cl.x + cl.w*0.5), -Infinity);
            const cfg = pickLayer();
            const nc = createCloud(Math.max(canvas.width+100, lastX + 120 + Math.random()*160), cfg);
            Object.assign(c, nc);
        }
        function drawClouds() {
            // Ordina per layer (lontane prima) per profondit√†
            clouds.sort((a,b)=> a.layer - b.layer);
            const now = Date.now();
            for (let c of clouds) {
                c.x -= c.speed; // movimento costante
                if (c.x + c.w < -80) {
                    recycleCloud(c);
                }
                const lightDir = { x:-0.6, y:-0.8 };
                ctx.save();
                ctx.translate(c.x + c.w/2, c.y + c.h/2);
                ctx.globalAlpha = c.alpha;
                // Costruisci forma
                ctx.beginPath();
                for (let i=0;i<c.lobeData.length;i++) {
                    const L = c.lobeData[i];
                    const bob = Math.sin((now/1700) + (c.x*0.015) + i*0.9) * (1.5 + c.layer);
                    ctx.ellipse(L.lx, L.ly + bob, L.rw, L.rh, 0, 0, Math.PI*2);
                }
                // Gradiente volumetrico
                const gradBody = ctx.createLinearGradient(-c.w/2, -c.h/2, c.w/2, c.h/2);
                gradBody.addColorStop(0, 'rgba(255,255,255,0.96)');
                gradBody.addColorStop(0.55, 'rgba(240,245,255,0.88)');
                gradBody.addColorStop(1, 'rgba(210,225,245,0.72)');
                ctx.fillStyle = gradBody;
                ctx.shadowColor = 'rgba(255,255,255,0.9)';
                ctx.shadowBlur = c.blur;
                ctx.fill();
                // Ombra inferiore / retro
                ctx.globalCompositeOperation = 'source-atop';
                const shade = ctx.createLinearGradient(0,-c.h/2,0,c.h/2);
                shade.addColorStop(0,'rgba(0,0,0,0)');
                shade.addColorStop(0.55,'rgba(0,0,0,0)');
                shade.addColorStop(1,'rgba(0,0,0,0.13)');
                ctx.fillStyle = shade;
                ctx.fill();
                // Highlight direzionale (uno solo per nuvola)
                ctx.globalCompositeOperation = 'lighter';
                const rimR = Math.min(c.w, c.h) * 0.22;
                const hx = -c.w/4 - lightDir.x * 6;
                const hy = -c.h/4 - lightDir.y * 6;
                const highlight = ctx.createRadialGradient(hx, hy, rimR*0.1, hx, hy, rimR);
                highlight.addColorStop(0,'rgba(255,255,255,0.7)');
                highlight.addColorStop(1,'rgba(255,255,255,0)');
                ctx.beginPath();
                ctx.ellipse(hx, hy, rimR, rimR*0.7, 0, 0, Math.PI*2);
                ctx.fillStyle = highlight;
                ctx.fill();
                ctx.restore();
            }
        }
        function drawParallax() {
            for (let elem of parallaxElements) {
                ctx.save();
                if (elem.type === 'island') {
                    ctx.fillStyle = '#e2c97b';
                    ctx.beginPath();
                    ctx.ellipse(elem.x, elem.y, elem.w/2, elem.h/2, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.ellipse(elem.x, elem.y-elem.h/2+8, elem.w/3, elem.h/4, 0, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    // nave stilizzata con teschio sulla vela e scritta "DNAS" sullo scafo
                    const hullX = elem.x - elem.w/2;
                    const hullY = elem.y;
                    const hullW = elem.w;
                    const hullH = elem.h/2;

                    // Scafo
                    ctx.fillStyle = '#8B5A2B';
                    ctx.fillRect(hullX, hullY, hullW, hullH);

                    // Vela (triangolo bianco)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y);
                    ctx.lineTo(elem.x + elem.w/4, elem.y - elem.h/2);
                    ctx.lineTo(elem.x - elem.w/4, elem.y - elem.h/2);
                    ctx.closePath();
                    ctx.fill();

                    // Teschio nero sulla vela (centro approssimato della vela)
                    const sailCX = elem.x;
                    const sailCY = elem.y - elem.h/2 + (elem.h * 0.18);
                    const skullR = Math.max(4, Math.min(8, Math.floor(elem.h * 0.18)));
                    // testa
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(sailCX, sailCY, skullR, 0, Math.PI * 2);
                    ctx.fill();
                    // mandibola
                    ctx.beginPath();
                    ctx.moveTo(sailCX - skullR * 0.7, sailCY + skullR * 0.5);
                    ctx.quadraticCurveTo(sailCX, sailCY + skullR * 1.1, sailCX + skullR * 0.7, sailCY + skullR * 0.5);
                    ctx.lineTo(sailCX - skullR * 0.7, sailCY + skullR * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    // occhi (fori bianchi)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(sailCX - skullR * 0.35, sailCY - skullR * 0.2, skullR * 0.22, 0, Math.PI * 2);
                    ctx.arc(sailCX + skullR * 0.35, sailCY - skullR * 0.2, skullR * 0.22, 0, Math.PI * 2);
                    ctx.fill();
                    // naso (triangolino)
                    ctx.beginPath();
                    ctx.moveTo(sailCX, sailCY + skullR * 0.05);
                    ctx.lineTo(sailCX - skullR * 0.12, sailCY + skullR * 0.35);
                    ctx.lineTo(sailCX + skullR * 0.12, sailCY + skullR * 0.35);
                    ctx.closePath();
                    ctx.fill();

                    // Scritta "DNAS" sullo scafo
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.max(8, Math.floor(hullH * 0.6))}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('DNAS', hullX + hullW / 2, hullY + hullH / 2 + 1);
                }
                ctx.restore();
            }
            // --- Mare in basso (parallax animato) ---
            drawSeaParallax();
        }

        // Mare: onde che scorrono orizzontalmente
        function drawSeaParallax() {
            const t = Date.now() / 1000;
            const baseY = canvas.height - 38;
            const h = 38;
            const waveLen = 110;
            const amp = 7;
            const speed = 32; // px/sec
            ctx.save();
            ctx.globalAlpha = 0.82;
            // Onda principale
            ctx.beginPath();
            for (let x = 0; x <= canvas.width+2; x += 2) {
                const y = baseY + Math.sin((x + t*speed) / waveLen) * amp + Math.sin((x - t*speed*0.7) / (waveLen*0.6)) * 2.5;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            // Gradiente azzurro trasparente
            const grad = ctx.createLinearGradient(0, baseY, 0, canvas.height);
            grad.addColorStop(0, '#b3e6ff');
            grad.addColorStop(0.5, '#5ec6e6');
            grad.addColorStop(1, 'rgba(0,80,180,0.85)');
            ctx.fillStyle = grad;
            ctx.shadowColor = '#b3e6ff';
            ctx.shadowBlur = 12;
            ctx.fill();
            ctx.globalAlpha = 1;
            // Cresta bianca semitrasparente
            ctx.beginPath();
            for (let x = 0; x <= canvas.width+2; x += 4) {
                const y = baseY + Math.sin((x + t*speed) / waveLen) * amp - 2;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.strokeStyle = 'rgba(255,255,255,0.32)';
            ctx.lineWidth = 2.2;
            ctx.shadowColor = 'rgba(255,255,255,0.18)';
            ctx.shadowBlur = 6;
            ctx.stroke();
            ctx.restore();
        }

        function drawHintOverlay() {
            if (!showHint) return;
            const w = canvas.width * 0.8;
            const h = 90;
            const x = (canvas.width - w) / 2;
            const y = canvas.height * 0.35;

            ctx.save();
            // pannello semitrasparente
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);

            // testo
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('TAP per volare', canvas.width/2, y + h/2 - 8);
            ctx.font = '14px Arial';
            ctx.fillText('Raccogli RUM per fare punti', canvas.width/2, y + h/2 + 16);
            ctx.restore();
        }

        function isSafeStartActive() {
            return Date.now() < safeStartEndTime;
        }

        function drawParticles() {
            for (let i = particles.length-1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                ctx.save();
                ctx.globalAlpha = Math.max(0, p.life/20);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
                if (p.life <= 0) particles.splice(i,1);
            }
        }

        function spawnParticles(x, y, color='#ffd700') {
            for (let i=0; i<12; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random()-0.5)*2.5,
                    vy: (Math.random()-0.5)*2.5,
                    size: 2+Math.random()*2,
                    color,
                    life: 18+Math.random()*8
                });
            }
        }

        // Ostacoli volanti (barili volanti e gabbiani)
        const FLYING_OBSTACLE_WIDTH = 48;
        const FLYING_OBSTACLE_HEIGHT = 36;
    const FLYING_OBSTACLE_SPEED = 2.8;
        let flyingObstacles = [];


        // --- Game Platform: invia punteggio a Telegram ---
        function telegramShareScore(score) {
            if (window.TelegramGameProxy && typeof TelegramGameProxy.shareScore === 'function') {
                TelegramGameProxy.shareScore(score);
            }
        }

        // Musica di sottofondo (avvio al primo TAP)
        const MUSIC_URL = 'https://noncolpito.github.io/DNASound/dnas.mp3'; // link mp3
        let bgm = null;
        let isMuted = false;
        function setupBgm(url) {
            if (bgm) return;
            try {
                bgm = new Audio(url);
                bgm.loop = true;
                bgm.volume = 0.4; // regola volume a piacere
                bgm.preload = 'auto';
            } catch (_) { /* no-op */ }
        }
        function ensureBgmPlaying() {
            if (!bgm || isMuted) return;
            const p = bgm.play();
            if (p && typeof p.catch === 'function') p.catch(() => {});
        }
        function toggleMute() {
            const btn = document.getElementById('muteBtn');
            isMuted = !isMuted;
            if (bgm) {
                bgm.muted = isMuted;
                if (isMuted) {
                    bgm.pause();
                } else {
                    ensureBgmPlaying();
                }
            }
            btn.textContent = isMuted ? 'üîá' : 'üîä';
        }


        function resetObstacles() {
            obstacles = [createObstacle(canvas.width)];
        }
        function createObstacle(x) {
            // Usa l'obstacleGap attuale come ampiezza per questo ostacolo (cos√¨ resta consistente se la difficolt√† cambia dopo)
            const gapSize = obstacleGap;
            const minGap = 60;
            const maxGap = canvas.height - 60 - gapSize;
            const gapY = Math.floor(Math.random() * (maxGap - minGap + 1)) + minGap;
            return { x: x, gapY: gapY, gap: gapSize, passed: false };
        }

        function resetBottles() {
            bottles = [createBottle(canvas.width + 200)];
        }
        function createBottle(x) {
            const minY = 80;
            const maxY = canvas.height - 80;
            let y;
            if (obstacles.length) {
                const last = obstacles[obstacles.length - 1];
                const target = last.gapY + obstacleGap / 2;
                const spread = obstacleGap * 0.6;
                y = target + (Math.random() - 0.5) * spread;
                y = Math.max(minY, Math.min(maxY, y));
            } else {
                y = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
            }
            return { x: x, y: y, collected: false };
        }

        function resetFlyingObstacles() {
            flyingObstacles = [createFlyingObstacle(canvas.width + 100)];
        }
        function createFlyingObstacle(x) {
            const type = Math.random() < 0.5 ? 'barile' : 'gabbiano';
            const minY = 60;
            const maxY = canvas.height - 200;
            const y = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
            return { x: x, y: y, type: type, passed: false };
        }
function drawFlyingObstacle(obs) {
    ctx.save();
    if (obs.type === 'barile') {
        // Barile dettagliato
        // Corpo
        ctx.save();
        ctx.beginPath();
        ctx.ellipse(obs.x + FLYING_OBSTACLE_WIDTH/2, obs.y + FLYING_OBSTACLE_HEIGHT/2, FLYING_OBSTACLE_WIDTH/2, FLYING_OBSTACLE_HEIGHT/2, 0, 0, Math.PI * 2);
        ctx.fillStyle = '#a0522d';
        ctx.shadowColor = '#654321';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        // Doghe
        ctx.strokeStyle = '#8B5A2B';
        ctx.lineWidth = 2;
        for (let i = 1; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(obs.x + i * FLYING_OBSTACLE_WIDTH/4, obs.y + 6);
            ctx.lineTo(obs.x + i * FLYING_OBSTACLE_WIDTH/4, obs.y + FLYING_OBSTACLE_HEIGHT - 6);
            ctx.stroke();
        }
        // Anelli metallici
        ctx.strokeStyle = '#bbb';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(obs.x + FLYING_OBSTACLE_WIDTH/2, obs.y + 8, FLYING_OBSTACLE_WIDTH/2.1, 5, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(obs.x + FLYING_OBSTACLE_WIDTH/2, obs.y + FLYING_OBSTACLE_HEIGHT - 8, FLYING_OBSTACLE_WIDTH/2.1, 5, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    } else {
        // Gabbiano migliorato
        ctx.save();
        const cx = obs.x + FLYING_OBSTACLE_WIDTH/2;
        const cy = obs.y + FLYING_OBSTACLE_HEIGHT/2;

        // Ombra lieve
        ctx.shadowColor = 'rgba(0,0,0,0.25)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetY = 1;

        // Corpo con gradiente
        const bodyGrad = ctx.createLinearGradient(cx - 12, cy - 10, cx + 12, cy + 10);
        bodyGrad.addColorStop(0, '#f6f6f6');
        bodyGrad.addColorStop(1, '#d9d9d9');
        ctx.beginPath();
        ctx.ellipse(cx, cy, 16, 10, Math.PI/14, 0, Math.PI * 2);
        ctx.fillStyle = bodyGrad;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.stroke();

        // Testa
        const headGrad = ctx.createRadialGradient(cx + 10, cy - 4, 1, cx + 8, cy - 4, 6);
        headGrad.addColorStop(0, '#ffffff');
        headGrad.addColorStop(1, '#e8e8e8');
        ctx.beginPath();
        ctx.arc(cx + 8, cy - 2, 6, 0, Math.PI * 2);
        ctx.fillStyle = headGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.12)';
        ctx.stroke();

        // Becco (superiore/inferiore) con sfumatura
        const beakGrad = ctx.createLinearGradient(cx + 12, cy - 4, cx + 24, cy + 2);
        beakGrad.addColorStop(0, '#ffd16a');
        beakGrad.addColorStop(1, '#ffae00');
        // superiore
        ctx.beginPath();
        ctx.moveTo(cx + 12, cy - 2);
        ctx.quadraticCurveTo(cx + 20, cy - 6, cx + 24, cy - 1);
        ctx.lineTo(cx + 13, cy - 1);
        ctx.closePath();
        ctx.fillStyle = beakGrad;
        ctx.fill();
        // inferiore
        ctx.beginPath();
        ctx.moveTo(cx + 12, cy - 1);
        ctx.quadraticCurveTo(cx + 19, cy + 2, cx + 23, cy + 1);
        ctx.lineTo(cx + 13, cy + 1);
        ctx.closePath();
        ctx.fillStyle = '#ffae00';
        ctx.fill();

        // Occhio con riflesso
        ctx.beginPath();
        ctx.arc(cx + 9, cy - 3, 1.6, 0, Math.PI * 2);
        ctx.fillStyle = '#111';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(cx + 9.6, cy - 3.4, 0.5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fill();

        // Ali animate
        const t = Date.now();
        const wingAngle = Math.sin((t + obs.x * 30) / 180) * 0.6;
        // Ala posteriore (pi√π trasparente)
        ctx.save();
        ctx.translate(cx - 6, cy - 2);
        ctx.rotate(-0.15 - wingAngle * 0.8);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-16, -8, -28, 0);
        ctx.quadraticCurveTo(-16, 6, 0, 0);
        ctx.fillStyle = 'rgba(210,210,210,0.7)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.12)';
        ctx.stroke();
        ctx.restore();
        // Ala anteriore
        ctx.save();
        ctx.translate(cx - 6, cy - 2);
        ctx.rotate(0.15 + wingAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-18, -10, -30, -2);
        ctx.quadraticCurveTo(-16, 8, 0, 0);
        ctx.fillStyle = '#e6e6e6';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.stroke();
        ctx.restore();

        // Coda
        ctx.beginPath();
        ctx.moveTo(cx - 12, cy + 2);
        ctx.lineTo(cx - 18, cy + 1);
        ctx.lineTo(cx - 16, cy + 5);
        ctx.closePath();
        ctx.fillStyle = '#dcdcdc';
        ctx.fill();

        ctx.restore(); // fine ramo gabbiano
    } // close else branch
    ctx.restore(); // restore outer save
}
// ====== Proiettili (chicchi di mais) ======
function fire() {
    if (!hasStarted || gameOver) return;
    if (ammo <= 0) return;
    ammo--;
    // posiziona proiettile davanti a Chico
    const px = 80 + CHICO_RADIUS - 4;
    const py = chicoY;
    // AUTO-MIRA: cerca il bersaglio volante pi√π vicino in avanti
    let target = null;
    let bestDist = Infinity;
    const shooterX = px;
    for (const fo of flyingObstacles) {
        const cx = fo.x + FLYING_OBSTACLE_WIDTH/2;
        const cy = fo.y + FLYING_OBSTACLE_HEIGHT/2;
        // Considera solo quelli davanti a Chico
        if (cx <= shooterX) continue;
        const dx = cx - shooterX;
        const dy = cy - py;
        const dist = Math.hypot(dx, dy);
        if (dist < bestDist) {
            bestDist = dist;
            target = { cx, cy };
        }
    }
    // Se nessun bersaglio volante, come fallback mira dritto
    const SPEED = 7.2; // velocit√† proiettile
    let vx = 6.2, vy = 0; // default
    if (target) {
        let dx = target.cx - shooterX;
        let dy = target.cy - py;
        const len = Math.hypot(dx, dy) || 1;
        vx = (dx / len) * SPEED;
        vy = (dy / len) * SPEED;
        // assicura che vada comunque avanti abbastanza velocemente
        if (vx < 3) {
            const boost = 3 - vx;
            const scale = (SPEED + boost) / SPEED;
            vx *= scale;
            vy *= scale;
        }
    }
    projectiles.push({ x: px, y: py, vx, vy, r: 6, born: Date.now(), target });
    spawnParticles(px, py, '#ffd34d');
}
function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        // Se ha un target e esiste ancora qualche ostacolo volante, ritocca la mira (leggera homing)
        if (p.target) {
            // trova ostacolo pi√π vicino alla posizione target memorizzata (o aggiorna se manca)
            let closest = null;
            let best = Infinity;
            for (const fo of flyingObstacles) {
                const cx = fo.x + FLYING_OBSTACLE_WIDTH/2;
                const cy = fo.y + FLYING_OBSTACLE_HEIGHT/2;
                if (cx < p.x) continue; // ignora quelli ormai dietro al proiettile
                const d = Math.hypot(cx - p.x, cy - p.y);
                if (d < best) { best = d; closest = { cx, cy }; }
            }
            if (closest) {
                // interpolazione verso il nuovo vettore
                const SPEED = Math.hypot(p.vx, p.vy) || 7.2;
                let dx = closest.cx - p.x;
                let dy = closest.cy - p.y;
                const len = Math.hypot(dx, dy) || 1;
                dx /= len; dy /= len;
                // blending per non cambiare direzione troppo bruscamente
                const blend = 0.18; // 0=no homing, 1=aggancio totale
                const curLen = Math.hypot(p.vx, p.vy) || SPEED;
                let curdx = p.vx / curLen;
                let curdy = p.vy / curLen;
                const ndx = curdx*(1-blend) + dx*blend;
                const ndy = curdy*(1-blend) + dy*blend;
                p.vx = ndx * SPEED;
                p.vy = ndy * SPEED;
            }
        }
        p.x += p.vx;
        p.y += p.vy;
        // disegna
        ctx.save();
        ctx.translate(p.x, p.y);
        const g = ctx.createRadialGradient(0,0,1,0,0,p.r);
        g.addColorStop(0,'#fffacd');
        g.addColorStop(0.4,'#ffe066');
        g.addColorStop(1,'#d48806');
        ctx.beginPath();
        ctx.arc(0,0,p.r,0,Math.PI*2);
        ctx.fillStyle = g;
        ctx.shadowColor = '#ffef9a';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.restore();
        // collisione con ostacoli volanti
        for (let j = flyingObstacles.length - 1; j >= 0; j--) {
            const fo = flyingObstacles[j];
            if (p.x + p.r > fo.x && p.x - p.r < fo.x + FLYING_OBSTACLE_WIDTH && p.y + p.r > fo.y && p.y - p.r < fo.y + FLYING_OBSTACLE_HEIGHT) {
                // distruggi ostacolo
                spawnParticles(fo.x + FLYING_OBSTACLE_WIDTH/2, fo.y + FLYING_OBSTACLE_HEIGHT/2, '#ffcf4d');
                flyingObstacles.splice(j,1);
                projectiles.splice(i,1);
                break;
            }
        }
        // rimuovi se fuori schermo
    const TTL = 4000; // ms
    if (projectiles[i] && ((p.x - p.r > canvas.width + 40) || Date.now() - p.born > TTL)) {
            projectiles.splice(i,1);
        }
    }
}

// ====== Corn pickup (pannocchia) ======
function spawnCornMaybe() {
    if (!hasStarted || gameOver) return;
    if (score - lastCornSpawnScore < CORN_MIN_SCORE_GAP) return;
    if (Math.random() < CORN_SPAWN_CHANCE / 60) { // mitigazione frame-rate
        const y = 90 + Math.random() * (canvas.height - 250);
        cornItems.push({ x: canvas.width + 40, y, collected: false });
        lastCornSpawnScore = score;
    }
}
function drawCornItem(item) {
    ctx.save();
    const bob = Math.sin((Date.now()+ item.x*30)/500)*3;
    ctx.translate(item.x, item.y + bob);
    // pannocchia stilizzata
    ctx.beginPath();
    ctx.ellipse(0,0,CORN_RADIUS*0.55,CORN_RADIUS*0.9,0,0,Math.PI*2);
    const grad = ctx.createLinearGradient(0,-CORN_RADIUS,0,CORN_RADIUS);
    grad.addColorStop(0,'#fff59d');
    grad.addColorStop(1,'#f1c40f');
    ctx.fillStyle = grad;
    ctx.strokeStyle = '#c49000';
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();
    // grani (puntini)
    ctx.fillStyle = 'rgba(255,165,0,0.55)';
    for (let i=0;i<10;i++) {
        ctx.beginPath();
        ctx.arc((Math.random()-0.5)*CORN_RADIUS*0.6,(Math.random()-0.5)*CORN_RADIUS*1.2,1.2,0,Math.PI*2);
        ctx.fill();
    }
    // foglie verdi
    ctx.restore();
}
// (Versione semplificata pannocchia senza foglie dettagliate)
function drawCornItem(item) {
    ctx.save();
    const bob = Math.sin((Date.now()+ item.x*30)/500)*3;
    ctx.translate(item.x, item.y + bob);
    ctx.beginPath();
    ctx.ellipse(0,0,CORN_RADIUS*0.55,CORN_RADIUS*0.9,0,0,Math.PI*2);
    const grad = ctx.createLinearGradient(0,-CORN_RADIUS,0,CORN_RADIUS);
    grad.addColorStop(0,'#fff59d');
    grad.addColorStop(1,'#f1c40f');
    ctx.fillStyle = grad;
    ctx.strokeStyle = '#c49000';
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();
    ctx.restore();
}

function drawChico(y) {
    ctx.save();
    const x = 80;

    // Aura scudo / flash consumo
    if (hasShield) {
        ctx.save();
        const pulse = 0.6 + Math.sin(Date.now()/180) * 0.25;
        const gradA = ctx.createRadialGradient(x, y, CHICO_RADIUS * 0.4, x, y, CHICO_RADIUS + 18);
        gradA.addColorStop(0, 'rgba(120,200,255,0.0)');
        gradA.addColorStop(0.55, 'rgba(120,200,255,0.20)');
        gradA.addColorStop(1, 'rgba(120,200,255,0.0)');
        ctx.beginPath();
        ctx.arc(x, y, CHICO_RADIUS + 14 + pulse * 4, 0, Math.PI * 2);
        ctx.fillStyle = gradA;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x, y, CHICO_RADIUS + 10 + pulse * 3, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(160,230,255,0.85)';
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(120,200,255,0.9)';
        ctx.shadowBlur = 12;
        ctx.stroke();
        ctx.restore();
    } else if (Date.now() < shieldBreakingEnd) {
        const remain = (shieldBreakingEnd - Date.now()) / SHIELD_BREAK_DURATION; // 1->0
        const rings = 3;
        for (let i=0;i<rings;i++) {
            const ratio = i / rings;
            const alpha = Math.max(0,(remain - ratio*0.25))*0.9;
            if (alpha <= 0) continue;
            ctx.save();
            const r = CHICO_RADIUS + 12 + ratio*36 + Math.sin(Date.now()/90 + i)*2;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(150,220,255,0.85)';
            ctx.lineWidth = 2 + (1-remain)*2;
            ctx.shadowColor = 'rgba(120,200,255,0.6)';
            ctx.shadowBlur = 8;
            ctx.stroke();
            ctx.restore();
        }
    }

    // Ombra dolce
    ctx.shadowColor = 'rgba(0,0,0,0.25)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 3;

    // Corpo (rosso) con gradiente e contorno
    const bodyGrad = ctx.createRadialGradient(x - 6, y - 8, CHICO_RADIUS * 0.2, x, y, CHICO_RADIUS);
    bodyGrad.addColorStop(0, '#ff3b30');
    bodyGrad.addColorStop(1, '#8c0000');
    ctx.beginPath();
    ctx.arc(x, y, CHICO_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = bodyGrad;
    ctx.fill();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = '#7a0000';
    ctx.stroke();

    // Pancia (giallo-oro) con gradiente e highlight
    ctx.shadowBlur = 0;
    const bellyGrad = ctx.createRadialGradient(x, y + 10, CHICO_RADIUS * 0.2, x, y + 10, CHICO_RADIUS * 0.7);
    bellyGrad.addColorStop(0, '#ffe680');
    bellyGrad.addColorStop(1, '#d4b200');
    ctx.beginPath();
    ctx.arc(x, y + 10, CHICO_RADIUS * 0.7, 0, Math.PI * 2);
    ctx.fillStyle = bellyGrad;
    ctx.fill();
    // Piccolo riflesso pancia
    ctx.beginPath();
    ctx.arc(x - 8, y + 2, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fill();

    // Coda a piume (rosso, giallo, blu)
    ctx.save();
    ctx.translate(x, y + CHICO_RADIUS - 2);
    ctx.rotate(Math.PI / 8);
    const tailColors = ['#ff3b30', '#ffd700', '#0078ff'];
    for (let i = 0; i < tailColors.length; i++) {
        ctx.beginPath();
        ctx.moveTo(-2 - i * 2, 0);
        ctx.quadraticCurveTo(-16 - i * 4, 16 + i * 2, -2 - i * 2, 28 + i * 2);
        ctx.quadraticCurveTo(2 - i, 20 + i * 2, -2 - i * 2, 0);
        ctx.fillStyle = tailColors[i];
        ctx.globalAlpha = 0.9 - i * 0.15;
        ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();

    // Piume decorative rosse
    for (let i = 0; i < 4; i++) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(Math.PI / 7 * i);
        ctx.beginPath();
        ctx.moveTo(-CHICO_RADIUS + 6, -6);
        ctx.quadraticCurveTo(-CHICO_RADIUS - 6, -10, -CHICO_RADIUS + 1, -1);
        ctx.strokeStyle = '#ff5a5f';
        ctx.lineWidth = 1.6;
        ctx.stroke();
        ctx.restore();
    }

    // Ali animate con gradiente
    let wingAngle = Math.sin(Date.now() / 120) * 0.5 + (chicoVY < 0 ? -0.7 : 0);
    for (let i = 0; i < 3; i++) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(wingAngle + i * 0.1);
        const cx = -18, cy = i * 2, rx = 18 - i * 2, ry = 8;
        const wingGrad = ctx.createRadialGradient(cx - 6, cy - 4, 2, cx, cy, rx);
        wingGrad.addColorStop(0, '#ff6666');
        wingGrad.addColorStop(1, '#b10000');
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, Math.PI / 4, 0, Math.PI * 2);
        ctx.fillStyle = wingGrad;
        ctx.globalAlpha = 0.78 - i * 0.18;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(122,0,0,0.6)';
        ctx.stroke();
        ctx.restore();
    }

    // Becco con shading
    ctx.save();
    // Parte superiore
    const upperBeakGrad = ctx.createLinearGradient(x + CHICO_RADIUS, y - 8, x + CHICO_RADIUS + 18, y);
    upperBeakGrad.addColorStop(0, '#ffb347');
    upperBeakGrad.addColorStop(1, '#ff8c00');
    ctx.beginPath();
    ctx.moveTo(x + CHICO_RADIUS, y - 6);
    ctx.quadraticCurveTo(x + CHICO_RADIUS + 10, y - 10, x + CHICO_RADIUS + 18, y - 2);
    ctx.lineTo(x + CHICO_RADIUS + 1, y - 2);
    ctx.closePath();
    ctx.fillStyle = upperBeakGrad;
    ctx.fill();
    // Parte inferiore
    const lowerBeakGrad = ctx.createLinearGradient(x + CHICO_RADIUS, y, x + CHICO_RADIUS + 16, y + 6);
    lowerBeakGrad.addColorStop(0, '#ff9e2c');
    lowerBeakGrad.addColorStop(1, '#e67600');
    ctx.beginPath();
    ctx.moveTo(x + CHICO_RADIUS, y - 2);
    ctx.quadraticCurveTo(x + CHICO_RADIUS + 10, y + 5, x + CHICO_RADIUS + 16, y + 2);
    ctx.lineTo(x + CHICO_RADIUS, y + 4);
    ctx.closePath();
    ctx.fillStyle = lowerBeakGrad;
    ctx.fill();
    // Linea bocca
    ctx.beginPath();
    ctx.moveTo(x + CHICO_RADIUS + 2, y);
    ctx.quadraticCurveTo(x + CHICO_RADIUS + 8, y + 2, x + CHICO_RADIUS + 14, y + 1);
    ctx.strokeStyle = 'rgba(120,60,0,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    // Orecchino d'oro con highlight
    const ringGrad = ctx.createRadialGradient(x + 3, y + CHICO_RADIUS / 2 - 1, 0.5, x + 4, y + CHICO_RADIUS / 2, 4);
    ringGrad.addColorStop(0, '#fff2a8');
    ringGrad.addColorStop(1, '#d4a700');
    ctx.beginPath();
    ctx.arc(x + 4, y + CHICO_RADIUS / 2, 4, 0, Math.PI * 2);
    ctx.fillStyle = ringGrad;
    ctx.fill();
    ctx.strokeStyle = '#9b7500';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Occhio con bordo e riflessi
    ctx.beginPath();
    ctx.arc(x + 14, y - 8, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 1;
    ctx.stroke();
    // Pupilla
    ctx.beginPath();
    ctx.arc(x + 16, y - 8, 2.2, 0, Math.PI * 2);
    ctx.fillStyle = 'black';
    ctx.fill();
    // Riflessi
    ctx.beginPath();
    ctx.arc(x + 12, y - 10, 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + 17.5, y - 6.5, 0.8, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fill();

    // Benda da pirata
    ctx.save();
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(x + 14, y - 8, 6, Math.PI * 0.2, Math.PI * 0.8);
    ctx.stroke();
    // Nodo della benda
    ctx.beginPath();
    ctx.moveTo(x + 20, y - 13);
    ctx.quadraticCurveTo(x + 25, y - 10, x + 22, y - 5);
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.restore();

    // Cappello da pirata con gradiente e bordo dorato
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = 5;
    ctx.shadowOffsetY = 2;
    const hatGrad = ctx.createLinearGradient(x + 2, y - CHICO_RADIUS - 18, x + 34, y - CHICO_RADIUS + 8);
    hatGrad.addColorStop(0, '#111');
    hatGrad.addColorStop(1, '#2a2a2a');
    ctx.beginPath();
    ctx.moveTo(x + 2, y - CHICO_RADIUS - 2);
    ctx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 18, x + 34, y - CHICO_RADIUS + 6);
    ctx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 8, x + 2, y - CHICO_RADIUS - 2);
    ctx.closePath();
    ctx.fillStyle = hatGrad;
    ctx.fill();
    // Bordo dorato
    ctx.beginPath();
    ctx.moveTo(x + 2, y - CHICO_RADIUS - 2);
    ctx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 18, x + 34, y - CHICO_RADIUS + 6);
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Highlight cappello
    ctx.beginPath();
    ctx.moveTo(x + 8, y - CHICO_RADIUS - 8);
    ctx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 14, x + 28, y - CHICO_RADIUS - 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Teschio sul cappello
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(x + 18, y - CHICO_RADIUS - 8, 5, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + 16, y - CHICO_RADIUS - 8, 1, 0, Math.PI * 2);
    ctx.arc(x + 20, y - CHICO_RADIUS - 8, 1, 0, Math.PI * 2);
    ctx.fillStyle = 'black';
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 15, y - CHICO_RADIUS - 5);
    ctx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 3, x + 21, y - CHICO_RADIUS - 5);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    ctx.restore();
}

// --- Power-up Scudo (tridente) ---
function drawShieldItem(item) {
    ctx.save();
    const t = Date.now();
    const bob = Math.sin((t + item.x * 40) / 600) * 4;
    ctx.translate(item.x, item.y + bob);

    // Soft ambient aura
    const aura = ctx.createRadialGradient(0,0,6,0,0,SHIELD_RADIUS+18);
    aura.addColorStop(0,'rgba(120,200,255,0.45)');
    aura.addColorStop(0.5,'rgba(90,170,255,0.22)');
    aura.addColorStop(1,'rgba(90,170,255,0)');
    ctx.beginPath();
    ctx.arc(0,0,SHIELD_RADIUS+18,0,Math.PI*2);
    ctx.fillStyle = aura;
    ctx.fill();

    // Outer metallic ring
    ctx.beginPath();
    ctx.arc(0,0,SHIELD_RADIUS+4,0,Math.PI*2);
    const ringGrad = ctx.createLinearGradient(-SHIELD_RADIUS-4,-SHIELD_RADIUS-4,SHIELD_RADIUS+4,SHIELD_RADIUS+4);
    ringGrad.addColorStop(0,'#e6f6ff');
    ringGrad.addColorStop(0.35,'#7fc2e6');
    ringGrad.addColorStop(0.6,'#3e7ba8');
    ringGrad.addColorStop(1,'#a2dfff');
    ctx.fillStyle = ringGrad;
    ctx.shadowColor = 'rgba(120,200,255,0.9)';
    ctx.shadowBlur = 10;
    ctx.fill();

    // Inner shield body (slightly inset)
    ctx.beginPath();
    ctx.arc(0,0,SHIELD_RADIUS-2,0,Math.PI*2);
    const coreGrad = ctx.createRadialGradient(-6,-6,4,0,0,SHIELD_RADIUS-2);
    coreGrad.addColorStop(0,'#c7ecff');
    coreGrad.addColorStop(0.35,'#62b8ff');
    coreGrad.addColorStop(0.75,'#0e5d94');
    coreGrad.addColorStop(1,'#083a5c');
    ctx.fillStyle = coreGrad;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.stroke();

    // Rotating light sweep (subtle)
    const sweepA = (t/900)% (Math.PI*2);
    ctx.save();
    ctx.rotate(sweepA);
    ctx.beginPath();
    ctx.ellipse(0,0,SHIELD_RADIUS-4, (SHIELD_RADIUS-4)*0.55, 0, -0.4, 0.4);
    const sweepGrad = ctx.createLinearGradient(-SHIELD_RADIUS,0,SHIELD_RADIUS,0);
    sweepGrad.addColorStop(0,'rgba(255,255,255,0)');
    sweepGrad.addColorStop(0.45,'rgba(255,255,255,0.0)');
    sweepGrad.addColorStop(0.5,'rgba(255,255,255,0.35)');
    sweepGrad.addColorStop(0.55,'rgba(255,255,255,0.0)');
    sweepGrad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = sweepGrad;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fill();
    ctx.restore();

    // Tridente stile Poseidone
    ctx.save();
    const triScale = 0.86;
    ctx.scale(triScale, triScale);
    ctx.lineJoin='round';
    ctx.lineCap='round';
    // Glow acqua esterno
    const poseGlow = ctx.createRadialGradient(0,-4,3,0,0,SHIELD_RADIUS);
    poseGlow.addColorStop(0,'rgba(160,235,255,0.85)');
    poseGlow.addColorStop(0.35,'rgba(120,210,255,0.35)');
    poseGlow.addColorStop(1,'rgba(120,210,255,0)');
    ctx.beginPath();
    ctx.arc(0,0,SHIELD_RADIUS-3,0,Math.PI*2);
    ctx.fillStyle = poseGlow;
    ctx.globalAlpha = 0.55;
    ctx.fill();
    ctx.globalAlpha = 1;
    // Silhouette base (pi√π spessa, scura blu)
    ctx.beginPath();
    // Asta centrale e punta
    ctx.moveTo(0,12);
    ctx.lineTo(0,-10);
    ctx.lineTo(-3,-10);
    ctx.lineTo(0,-24); // punta superiore
    ctx.lineTo(3,-10);
    ctx.lineTo(0,-10);
    // Prong sinistro curvo
    ctx.moveTo(0,-12);
    ctx.lineTo(-9,-4);
    ctx.quadraticCurveTo(-12,-2,-12,0);
    ctx.lineTo(-12,-8);
    ctx.quadraticCurveTo(-12,-14,-8,-18);
    ctx.lineTo(-6,-14);
    ctx.quadraticCurveTo(-8,-10,-6,-8);
    ctx.lineTo(0,-14);
    // Prong destro curvo
    ctx.moveTo(0,-12);
    ctx.lineTo(9,-4);
    ctx.quadraticCurveTo(12,-2,12,0);
    ctx.lineTo(12,-8);
    ctx.quadraticCurveTo(12,-14,8,-18);
    ctx.lineTo(6,-14);
    ctx.quadraticCurveTo(8,-10,6,-8);
    ctx.lineTo(0,-14);
    // Barra decorativa / guardia
    ctx.moveTo(-8,2);
    ctx.lineTo(8,2);
    // Anello piccolo
    ctx.moveTo(0,2);
    ctx.arc(0,2,2,0,Math.PI*2);
    ctx.strokeStyle = '#012c44';
    ctx.lineWidth = 7.4;
    ctx.stroke();
    // Riempimento dorato
    const gold = ctx.createLinearGradient(0,-24,0,12);
    gold.addColorStop(0,'#fff6c9');
    gold.addColorStop(0.28,'#ffe178');
    gold.addColorStop(0.55,'#ffc53a');
    gold.addColorStop(0.75,'#e6a300');
    gold.addColorStop(1,'#b87400');
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillStyle = gold;
    ctx.fillRect(-20,-28,40,46);
    ctx.globalCompositeOperation = 'source-over';
    // Bordo chiaro interno
    ctx.beginPath();
    ctx.moveTo(0,12); ctx.lineTo(0,-10); ctx.lineTo(-2,-10); ctx.lineTo(0,-20); ctx.lineTo(2,-10); ctx.lineTo(0,-10);
    ctx.moveTo(0,-12); ctx.lineTo(-8,-4); ctx.quadraticCurveTo(-10,-2,-10,-0.5); ctx.quadraticCurveTo(-10,-10,-6,-16);
    ctx.moveTo(0,-12); ctx.lineTo(8,-4); ctx.quadraticCurveTo(10,-2,10,-0.5); ctx.quadraticCurveTo(10,-10,6,-16);
    ctx.moveTo(-7,2); ctx.lineTo(7,2);
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.lineWidth = 2.2;
    ctx.stroke();
    // Highlight pulsante centrale
    const pulse = 0.5 + Math.sin(t/350)*0.5;
    ctx.beginPath();
    ctx.arc(0,2,2.4+pulse*0.6,0,Math.PI*2);
    const ring = ctx.createRadialGradient(0,2,0.5,0,2,3.2);
    ring.addColorStop(0,'rgba(255,255,255,0.95)');
    ring.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = ring;
    ctx.fill();
    ctx.restore();

    // Small specular spot
    ctx.beginPath();
    ctx.arc(-6,-8,5,0,Math.PI*2);
    const spot = ctx.createRadialGradient(-7,-9,1,-6,-8,5);
    spot.addColorStop(0,'rgba(255,255,255,0.95)');
    spot.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = spot;
    ctx.fill();

    ctx.restore();
}
function spawnShieldMaybe() {
    if (hasShield || shieldItems.length>0) return;
    if (score - lastShieldSpawnScore < SHIELD_MIN_SCORE_GAP) return;
    if (hasStarted && Math.random() < SHIELD_SPAWN_CHANCE) {
        const y = 100 + Math.random() * (canvas.height - 220);
        shieldItems.push({ x: canvas.width + 40, y, collected:false });
        lastShieldSpawnScore = score;
    }
}
function consumeShieldEffect() {
    if (!hasShield) return;
    hasShield = false;
    shieldCharges = 0;
    shieldBreakingEnd = Date.now() + SHIELD_BREAK_DURATION;
    shieldInvulnUntil = shieldBreakingEnd; // invulnerabile finch√© dura l'anim di rottura
    spawnParticles(80, chicoY, '#9fdfff');
}

function drawBottle(bottle) {
    ctx.save();
    const bob = Math.sin((Date.now() + bottle.x * 50) / 500) * 3;
    ctx.translate(bottle.x, bottle.y + bob);
    ctx.rotate(-Math.PI/8);

    // Corpo in vetro
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(0, 0, BOTTLE_RADIUS, BOTTLE_RADIUS*1.3, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.stroke();

    // Liquido (rum ambrato)
    ctx.beginPath();
    ctx.ellipse(0, 4, BOTTLE_RADIUS*0.9, BOTTLE_RADIUS*0.9, 0, 0, Math.PI*2);
    ctx.fillStyle = '#c97e2b';
    ctx.globalAlpha = 0.85;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();

    // Collo della bottiglia
    ctx.fillStyle = '#e0e0e0';
    ctx.fillRect(-4, -BOTTLE_RADIUS*1.3-10, 8, 18);
    // Tappo
    ctx.fillStyle = '#5b2b17';
    ctx.fillRect(-6, -BOTTLE_RADIUS*1.3-14, 12, 6);

    // Etichetta con "R"
    ctx.fillStyle = '#fff';
    ctx.fillRect(-10, -2, 20, 12);
    ctx.strokeStyle = '#b33';
    ctx.lineWidth = 1;
    ctx.strokeRect(-10, -2, 20, 12);
    ctx.fillStyle = '#b33';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('R', 0, 4);

    ctx.restore();
}

        function drawObstacle(obs) {
            const gapSize = obs.gap !== undefined ? obs.gap : obstacleGap; // fallback se vecchio oggetto
            ctx.save();
            ctx.fillStyle = '#8B5A2B';
            ctx.fillRect(obs.x, 0, OBSTACLE_WIDTH, obs.gapY);
            ctx.fillRect(obs.x, obs.gapY + gapSize, OBSTACLE_WIDTH, canvas.height - obs.gapY - gapSize);
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 4;
            ctx.strokeRect(obs.x, 0, OBSTACLE_WIDTH, obs.gapY);
            ctx.strokeRect(obs.x, obs.gapY + gapSize, OBSTACLE_WIDTH, canvas.height - obs.gapY - gapSize);
            ctx.restore();
        }

        function updateDifficulty() {
            // scala progressione in base alla difficolt√† selezionata
            const speedBoost = Math.min(score * 0.05 * diffScale, 1.8 * diffScale);
            obstacleSpeed = baseObstacleSpeed + speedBoost;
            // limite minimo dinamico (non meno di base-120 e non meno di 200)
            const minGap = Math.max(baseObstacleGap - 120, 200);
            obstacleGap = Math.max(minGap, baseObstacleGap - score * 2 * diffScale);
        }

        function applyDifficulty(key) {
            if (!DIFFICULTIES[key]) return;
            currentDifficulty = key;
            const cfg = DIFFICULTIES[key];
            baseObstacleGap = cfg.gap;
            baseObstacleSpeed = cfg.speed;
            gravity = cfg.gravity;
            diffScale = cfg.dynamicScale;
            obstacleGap = baseObstacleGap;
            obstacleSpeed = baseObstacleSpeed;
            // reset elementi per coerenza visiva pre-start
            resetObstacles();
            resetBottles();
            resetFlyingObstacles();
            chicoY = canvas.height / 2;
            chicoVY = 0;
            score = 0;
            gameOver = false;
            hasStarted = false;
            showHint = true;
            safeStartEndTime = 0;
            difficultyChosen = true; // abilitato avvio
            const info = document.getElementById('diffInfo');
            if (info) info.textContent = capitalizeFirst(key) + ': ' + cfg.desc + ' TAP per iniziare!';
        }
        function capitalizeFirst(s){return s.charAt(0).toUpperCase()+s.slice(1);}        

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawClouds();
                drawParallax();
            drawParticles();

            // Fase pre-avvio: scena statica con suggerimento
            if (!hasStarted && !gameOver) {
                for (let i = 0; i < obstacles.length; i++) {
                    drawObstacle(obstacles[i]);
                }
                for (let i = 0; i < bottles.length; i++) {
                    if (!bottles[i].collected) drawBottle(bottles[i]);
                }
                // Chico con lieve dondolio senza fisica
                const bob = Math.sin(Date.now() / 400) * 3;
                drawChico(chicoY + bob);
                drawHintOverlay();
                document.getElementById('score').textContent = `RUM: ${score}`;
                requestAnimationFrame(gameLoop);
                return;
            }

            updateDifficulty();
            // Possibile spawn scudo
            spawnShieldMaybe();
            // Possibile spawn pannocchia
            spawnCornMaybe();
            // Ostacoli (barili a terra/cielo)
            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                obs.x -= obstacleSpeed;
                drawObstacle(obs);
                // Collisione con il bordo del gap
                if (
                    80 + CHICO_RADIUS > obs.x &&
                    80 - CHICO_RADIUS < obs.x + OBSTACLE_WIDTH
                ) {
                    const gapSizeColl = obs.gap !== undefined ? obs.gap : obstacleGap;
                    const outGap = (chicoY - CHICO_RADIUS < obs.gapY || chicoY + CHICO_RADIUS > obs.gapY + gapSizeColl);
                    if (outGap && hasShield) {
                        consumeShieldEffect();
                    } else if (outGap && !isSafeStartActive() && Date.now() >= shieldInvulnUntil) {
                        gameOver = true;
                    }
                }
                // Punteggio solo tramite bottiglie: non incrementare qui
                obs.passed = obs.passed || (obs.x + OBSTACLE_WIDTH < 80 - CHICO_RADIUS);
            }
            // Pulisci ostacoli usciti dallo schermo
            if (obstacles.length && obstacles[0].x + OBSTACLE_WIDTH < 0) {
                obstacles.shift();
            }
            // Genera nuovi ostacoli a distanza regolare
            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 220) {
                obstacles.push(createObstacle(canvas.width + Math.random() * 120));
            }
            // Ostacoli volanti solo dopo 10 punti
            if (score >= 5) {
                for (let i = 0; i < flyingObstacles.length; i++) {
                    let obs = flyingObstacles[i];
                    const flySpeed = Math.max(obstacleSpeed * 1.15, 2.2);
                    obs.x -= flySpeed;
                    if (obs.type === 'gabbiano') {
                        obs.y += Math.sin((Date.now() + obs.x * 20) / 600) * 0.6;
                    }
                    drawFlyingObstacle(obs);
                    if (
                        80 + CHICO_RADIUS > obs.x &&
                        80 - CHICO_RADIUS < obs.x + FLYING_OBSTACLE_WIDTH &&
                        chicoY + CHICO_RADIUS > obs.y &&
                        chicoY - CHICO_RADIUS < obs.y + FLYING_OBSTACLE_HEIGHT
                    ) {
                        if (hasShield) {
                            consumeShieldEffect();
                        } else if (!isSafeStartActive() && Date.now() >= shieldInvulnUntil) {
                            gameOver = true;
                        }
                    }
                    // Nessun incremento punteggio per ostacoli volanti
                    obs.passed = true;
                }
                if (flyingObstacles.length && flyingObstacles[0].x + FLYING_OBSTACLE_WIDTH < 0) {
                    flyingObstacles.shift();
                }
                if (flyingObstacles.length === 0 || flyingObstacles[flyingObstacles.length-1].x < canvas.width - 300) {
                    flyingObstacles.push(createFlyingObstacle(canvas.width + Math.random() * 200));
                }
            }

        // Bottiglie
            for (let i = 0; i < bottles.length; i++) {
                let bottle = bottles[i];
                bottle.x -= obstacleSpeed;
                if (!bottle.collected) {
                    drawBottle(bottle);
                }
                if (!bottle.collected && Math.hypot(bottle.x - 80, bottle.y - chicoY) < CHICO_RADIUS + BOTTLE_RADIUS) {
                    score += 1;
                    bottle.collected = true;
                    spawnParticles(bottle.x, bottle.y);
                }
            }
            // Rimuovi bottiglie raccolte o uscite dallo schermo
            bottles = bottles.filter(b => !b.collected && b.x + BOTTLE_RADIUS > 0);
            // Genera nuove bottiglie in coda
            if (bottles.length === 0 || bottles[bottles.length - 1].x < canvas.width - 260) {
                bottles.push(createBottle(canvas.width + 120 + Math.random() * 120));
            }

            // Chico physics
            chicoVY += gravity;
            chicoY += chicoVY;
            drawChico(chicoY);

            if (chicoY + CHICO_RADIUS > canvas.height || chicoY - CHICO_RADIUS < 0) {
                if (hasShield) {
                    consumeShieldEffect();
                    chicoVY = chicoY + CHICO_RADIUS > canvas.height ? -6 : 4;
                } else if (!isSafeStartActive() && Date.now() >= shieldInvulnUntil) {
                    gameOver = true;
                }
                chicoY = Math.min(Math.max(chicoY, CHICO_RADIUS + 2), canvas.height - CHICO_RADIUS - 2);
            }

            // Gestione oggetti scudo
            for (let i = shieldItems.length - 1; i >= 0; i--) {
                const item = shieldItems[i];
                item.x -= obstacleSpeed * 0.9;
                if (!item.collected) drawShieldItem(item);
                if (!item.collected && Math.hypot(item.x - 80, item.y - chicoY) < CHICO_RADIUS + SHIELD_RADIUS) {
                    item.collected = true;
                    hasShield = true;
                    shieldCharges = SHIELD_HITS;
                    shieldInvulnUntil = Date.now() + 120; // breve tolleranza subito dopo raccolta
                    spawnParticles(item.x, item.y, '#8fd8ff');
                }
                if (item.collected || item.x + SHIELD_RADIUS < -12) {
                    shieldItems.splice(i,1);
                }
            }

            // Gestione pannocchie (corn)
            for (let i = cornItems.length - 1; i >= 0; i--) {
                const item = cornItems[i];
                item.x -= obstacleSpeed * 0.95;
                if (!item.collected) drawCornItem(item);
                if (!item.collected && Math.hypot(item.x - 80, item.y - chicoY) < CHICO_RADIUS + CORN_RADIUS) {
                    item.collected = true;
                    ammo = Math.min(MAX_AMMO, ammo + 1);
                    spawnParticles(item.x, item.y, '#ffe066');
                }
                if (item.collected || item.x + CORN_RADIUS < -20) {
                    cornItems.splice(i,1);
                }
            }

            // Proiettili
            updateProjectiles();

            document.getElementById('score').textContent = `RUM: ${score}`;
            const ammoDisp = document.getElementById('ammoDisplay');
            if (ammoDisp) ammoDisp.textContent = 'üåΩ'.repeat(ammo);
            if (!gameOver) {
                requestAnimationFrame(gameLoop);
            } else {
                // suono rimosso
                telegramShareScore(score);
                ctx.font = 'bold 36px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText('Arr!', canvas.width/2, canvas.height/2);
            }
        }

        function flap() {
            // richiede prima la scelta della difficolt√†
            if (!difficultyChosen) return;
            if (!hasStarted && !gameOver) {
                hasStarted = true;
                showHint = false;
                safeStartEndTime = Date.now() + SAFE_START_DURATION;
                if (!bgm) setupBgm(MUSIC_URL);
                if (!isMuted) ensureBgmPlaying();
                chicoVY = FLAP;
                return;
            }
            if (!gameOver) {
                chicoVY = FLAP;
                // suono rimosso
            } else {
                // reset partita
                chicoY = canvas.height / 2;
                chicoVY = 0;
                score = 0;
                gameOver = false;
                hasStarted = false;
                resetClouds();
                showHint = true;
                safeStartEndTime = 0;
                resetObstacles();
                resetBottles();
                resetFlyingObstacles();
                shieldItems = [];
                hasShield = false;
                shieldCharges = 0;
                shieldBreakingEnd = 0;
                shieldInvulnUntil = 0;
                // reset shooting
                ammo = MAX_AMMO;
                projectiles = [];
                cornItems = [];
                lastCornSpawnScore = 0;
                const ammoDisp = document.getElementById('ammoDisplay');
                if (ammoDisp) ammoDisp.textContent = 'üåΩ'.repeat(ammo);
                gameLoop();
            }
        }
    resetClouds();
    // Input solo touch/mouse (mobile friendly)
    canvas.addEventListener('mousedown', flap);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); flap(); }, { passive: false });

    // Avvio: mostra hint, nessun movimento finch√© non si tocca
    resetObstacles();
    resetBottles();
    resetFlyingObstacles();
    shieldItems = [];
    hasShield = false;
    shieldCharges = 0;
    shieldBreakingEnd = 0;
    shieldInvulnUntil = 0;
    hasStarted = false;
    showHint = true;
    safeStartEndTime = 0;
    // Inizializza pulsanti UI
    document.getElementById('muteBtn').addEventListener('click', toggleMute);
    const diffOverlay = document.getElementById('difficultyOverlay');
    const diffButtonsWrap = document.getElementById('diffButtons');
    const diffInfo = document.getElementById('diffInfo');
    document.getElementById('diffGearBtn').addEventListener('click', () => {
        if (!hasStarted) {
            diffOverlay.style.display = 'flex';
        }
    });
    document.getElementById('fireBtn').addEventListener('click', fire);
    document.getElementById('fireBtn').addEventListener('touchstart', (e)=>{ e.preventDefault(); fire(); }, { passive:false });
    // Opzionale: tastiera per debug
    window.addEventListener('keydown', (e)=>{
        if (e.code === 'KeyF' || e.code === 'Space' || e.key === ' ' ) {
            e.preventDefault();
            fire();
        }
    });
    diffButtonsWrap.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-diff]');
        if (!btn) return;
        [...diffButtonsWrap.querySelectorAll('button')].forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        const key = btn.getAttribute('data-diff');
        applyDifficulty(key);
        if (diffInfo) diffInfo.textContent = capitalizeFirst(key) + ': ' + DIFFICULTIES[key].desc + ' TAP per iniziare!';
        // nascondi overlay subito dopo la scelta
        diffOverlay.style.display = 'none';
    });
    // Stato iniziale: difficolt√† normale selezionata visivamente ma non confermata -> richiede scelta
    difficultyChosen = false;
    // Inizializza munizioni visualizzate
    document.getElementById('ammoDisplay').textContent = 'üåΩ'.repeat(ammo);
    gameLoop();
    </script>
</body>
</html>
