<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <title>Flappy Chico</title>
    <style>
        body {
            background: linear-gradient(to bottom, #87ceeb 0%, #f0e68c 100%);
            margin: 0;
            overflow: hidden;
            font-family: 'Treasure Map Deadhand', Arial, sans-serif;
            /* Usa le aree sicure su iOS */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #87ceeb;
            border: 4px solid #222;
            box-shadow: 0 0 20px #222;
            /* Mobile friendly */
            touch-action: manipulation;
            -ms-touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            padding: 6px 18px;
            background: rgba(0,0,0,0.25);
            border: 2px solid rgba(255,255,255,0.25);
            border-radius: 14px;
            backdrop-filter: blur(6px) saturate(140%);
        }
        #muteBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            border: 2px solid #222;
            background: rgba(0,0,0,0.45);
            color: #fff;
            font-size: 18px;
            line-height: 1;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            text-shadow: 1px 1px 2px #000;
        }
    #muteBtn:active { transform: scale(0.98); }
        .diffPanel h1 {
            font-size: 40px;
            margin: 0 0 12px;
            letter-spacing: 1px;
            text-shadow: 0 4px 10px rgba(0,0,0,0.6);
        }
        .diffPanel p.subtitle {
            margin: 0 0 18px;
            font-size: 16px;
            letter-spacing: 0.5px;
            opacity: 0.9;
        }
        .diffButtons { display: flex; gap: 14px; justify-content: center; margin-bottom: 14px; flex-wrap: wrap; }
        .diffButtons button {
            flex: 1 1 90px;
            background: linear-gradient(160deg, #ffcc47, #ff8c00);
            border: none;
            border-radius: 18px;
            padding: 14px 8px 12px;
            color: #222;
            font-weight: 700;
            font-size: 15px;
            letter-spacing: 0.5px;
            cursor: pointer;
            position: relative;
            box-shadow: 0 4px 14px -4px rgba(0,0,0,0.6);
            transition: transform .18s, box-shadow .18s, background .4s;
        }
        .diffButtons button span.small {
            display: block;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.3px;
            opacity: 0.75;
            margin-top: 4px;
        }
        .diffButtons button.easy { background: linear-gradient(150deg,#7dffa0,#12d65b); }
        .diffButtons button.normal { background: linear-gradient(150deg,#51c6ff,#0066ff); color: #fff; }
        .diffButtons button.hard { background: linear-gradient(150deg,#ff5f89,#d4002f); color: #fff; }
        .diffButtons button:hover { transform: translateY(-4px); box-shadow: 0 10px 22px -10px rgba(0,0,0,0.9); }
        .diffButtons button:active { transform: translateY(1px); }
        .diffButtons button.active { outline: 3px solid rgba(255,255,255,0.9); }
        .diffInfo {
            font-size: 12px;
            line-height: 1.45;
            opacity: 0.85;
            padding: 0 8px;
            margin-top: 4px;
        }
        .tapHintInline { margin-top: 18px; font-size: 14px; opacity: 0.85; }
        @media (max-width: 480px){
            .diffPanel h1 { font-size: 32px; }
            .diffPanel { padding: 24px 20px 32px; }
            #score { font-size: 1.4em; }
        }
        #fireBtn {
            position: absolute;
            bottom: 18px;
            left: 16px;
            z-index: 12;
            width: 70px;
            height: 70px;
            border-radius: 18px;
            border: 3px solid rgba(255,255,255,0.4);
            background: radial-gradient(circle at 30% 30%, #ffe27a, #ff9f1c 65%, #cc6d00);
            color: #4b2200;
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 6px 18px -6px rgba(0,0,0,0.6), 0 0 0 3px rgba(0,0,0,0.3) inset;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.6);
            user-select: none;
            -webkit-user-select: none;
        }
        #fireBtn:active { transform: scale(.95); }
        #ammoDisplay {
            position: absolute;
            bottom: 94px;
            left: 22px;
            font-size: 22px;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            letter-spacing: 2px;
            z-index: 12;
            pointer-events: none;
        }
        /* Overlay difficolt√† centrato */
        #difficultyOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.45);
            z-index: 30;
        }
        #diffGearBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 48px;
            height: 48px;
            border-radius: 6px;
            font-size: 24px;
            line-height: 1;
            border: 2px solid #222;
            background: rgba(0,0,0,0.45);
            color: #fff;
            box-shadow: 0 0 20px #222;
            cursor: pointer;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            transition: transform .18s, box-shadow .18s;
        }
        #diffGearBtn:active { transform: scale(0.98); }
        .diffPanel {
            background: rgba(0,0,0,0.55);
            padding: 36px 44px 46px;
            border: 3px solid rgba(255,255,255,0.25);
            border-radius: 28px;
            box-shadow: 0 10px 28px -6px rgba(0,0,0,0.7), 0 0 0 4px rgba(255,255,255,0.07) inset;
            backdrop-filter: blur(10px) saturate(140%);
            max-width: 360px;
            text-align: center;
            color: #fff;
        }
        @media (max-width: 480px){
            .diffPanel { padding: 28px 24px 38px; border-radius: 24px; }
        }
    </style>
</head>
<body>
    <div id="score">RUM: 0</div>
    <div id="ammoDisplay" aria-label="Munizioni"></div>
    <button id="diffGearBtn" aria-label="Cambia difficolt√†" title="Difficolt√†">‚öôÔ∏è</button>
    <div id="difficultyOverlay" role="dialog" aria-modal="true">
        <div class="diffPanel">
            <h1>Flappy Chico</h1>
            <p class="subtitle">Scegli la difficolt√†</p>
            <div class="diffButtons" id="diffButtons">
                <button class="easy" data-diff="facile">Facile<span class="small">Gap ampio</span></button>
                <button class="normal active" data-diff="normale">Normale<span class="small">Esperienza base</span></button>
                <button class="hard" data-diff="difficile">Difficile<span class="small">Sfida!</span></button>
            </div>
            <div class="diffInfo" id="diffInfo">Normale: equilibrio tra velocit√† e spazio. Puoi cambiare prima di iniziare.</div>
            <div class="tapHintInline">Dopo aver scelto: TAP per volare</div>
        </div>
    </div>
    <button id="muteBtn" aria-label="Toggle audio" title="Audio">üîä</button>
    <button id="fireBtn" aria-label="Spara" title="Spara">üåΩ</button>
    <canvas id="gameCanvas" width="400" height="600"></canvas>

    <!-- Schermata Game Over -->
    <div id="gameOverScreen" style="display:none; position:fixed; inset:0; z-index:1001; background:rgba(0,0,0,0.7); color:#fff; display:none; align-items:center; justify-content:center;">
        <div style="background:rgba(30,30,30,0.92); border-radius:22px; padding:26px 20px 22px; width:90vw; max-width:360px; text-align:center; box-shadow:0 8px 32px #000;">
            <h2 style="margin:0 0 8px;">Game Over</h2>
            <p id="finalScoreText" style="margin:0 0 16px; font-size:18px;">Punteggio: 0</p>
            <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
                <button id="restartBtn" style="background-color:#0078d4; color:#fff; border:none; padding:12px 16px; font-size:16px; border-radius:10px; cursor:pointer; flex:1 1 140px;">‚Üª Rigioca</button>
                <!-- cambia in link https con target _blank e niente JS sul click -->
                <a id="sendScoreBtn"
                   class="send-score-btn"
                   href="#"
                   target="_blank"
                   rel="noopener"
                   style="background-color:#28a745; color:#fff; border:none; padding:12px 16px; font-size:16px; border-radius:10px; cursor:pointer; flex:1 1 140px; text-decoration:none; display:inline-block; text-align:center;">
                   üì§ Invia punteggio
                </a>
            </div>
            <!-- fallback visibile -->
            <div style="margin-top:8px;">
                <a id="scoreFallbackLink" href="#" target="_blank" rel="noopener" style="color:#9ad1ff; text-decoration:underline; font-size:12px;">
                    Se non si apre, tocca qui
                </a>
            </div>
        </div>
    </div>

    <script>
    // Adatta il canvas mantenendo rapporto 400x600: scala via CSS per riempire lo schermo
    function resizeGameCanvas() {
        try {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            const vw = window.innerWidth || document.documentElement.clientWidth;
            const vh = window.innerHeight || document.documentElement.clientHeight;
            const baseW = 400, baseH = 600;
            const scale = Math.min(vw / baseW, vh / baseH);
            // Risoluzione logica fissa per fisica/disegno
            if (canvas.width !== baseW) canvas.width = baseW;
            if (canvas.height !== baseH) canvas.height = baseH;
            // Scala visualmente via CSS per contenere interamente il gioco
            const cssW = Math.round(baseW * scale);
            const cssH = Math.round(baseH * scale);
            canvas.style.width = cssW + 'px';
            canvas.style.height = cssH + 'px';
            // Adatta overlay full-screen
            const tutOverlay = document.getElementById('tutorialOverlay');
            if (tutOverlay) tutOverlay.style.height = vh + 'px';
            const diffOverlay = document.getElementById('difficultyOverlay');
            if (diffOverlay) diffOverlay.style.height = vh + 'px';
        } catch (_) {}
    }
    window.addEventListener('resize', resizeGameCanvas);
    window.addEventListener('orientationchange', resizeGameCanvas);
    document.addEventListener('DOMContentLoaded', function(){
        // Alcuni WebView iOS aggiornano innerHeight dopo un tick
        resizeGameCanvas();
        setTimeout(resizeGameCanvas, 50);
        setTimeout(resizeGameCanvas, 300);
    });
        // Mostra tutorial solo alla prima partita (usa localStorage) - con guard per elementi mancanti
        window.addEventListener('DOMContentLoaded', function() {
            const tut = document.getElementById('tutorialOverlay');
            const closeBtn = document.getElementById('closeTutorialBtn');
            if (tut && !localStorage.getItem('chicoTutorialSeen')) {
                tut.style.display = 'block';
            }
            if (tut && closeBtn) {
                closeBtn.onclick = function() {
                    tut.style.display = 'none';
                    localStorage.setItem('chicoTutorialSeen','1');
                };
            }
        });
    // Costanti di gioco
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // Ottimizzazione: frame skip globale
    let globalFrameSkip = 0;
    // Ottimizzazione: pre-render Chico
    let chicoCache = null, chicoCacheKey = '';
    // Bot Telegram per deep-link punteggio
    const BOT_USERNAME = 'ChicoGiocaBot';
    let lastFinalScore = 0;

    // Costruisce deep-link (usa https per massima compatibilit√† nel WebView)
    function buildScoreLinks(score) {
        const s = encodeURIComponent(score);
        const bot = BOT_USERNAME;
        return {
            https: `https://t.me/${bot}?start=score_${s}`
        };
    }

    // Overlay Game Over: imposta gli href (niente listener che intercettano il click)
    function showGameOverScreen(finalScore) {
        try {
            lastFinalScore = finalScore;
            const panel = document.getElementById('gameOverScreen');
            const scoreEl = document.getElementById('finalScoreText');
            const sendBtn = document.getElementById('sendScoreBtn');
            const fbLink = document.getElementById('scoreFallbackLink');
            if (scoreEl) scoreEl.textContent = 'Punteggio: ' + finalScore;
            const link = buildScoreLinks(finalScore).https;
            if (sendBtn) sendBtn.setAttribute('href', link);
            if (fbLink) fbLink.setAttribute('href', link);
            if (panel) panel.style.display = 'flex';
        } catch (_) {}
    }
    function hideGameOverScreen() {
        const panel = document.getElementById('gameOverScreen');
        if (panel) panel.style.display = 'none';
    }
    const GRAVITY_BASE = 0.33; // val base normal (ridotto)
        let gravity = GRAVITY_BASE;
    const FLAP = -5.2; // salto meno potente
        const CHICO_RADIUS = 24;
        let chicoY = canvas.height / 2;
        let chicoVY = 0;
    let score = 0;
        let gameOver = false;
        // Start & safe-start
        let hasStarted = false;
        let showHint = true;
        const SAFE_START_DURATION = 1600; // ms di invulnerabilit√† iniziale
        let safeStartEndTime = 0;

        // Ostacoli (barili)
        const OBSTACLE_WIDTH = 60;
    const OBSTACLE_GAP_DEFAULT = 320;
    const OBSTACLE_SPEED_DEFAULT = 2.4;
    // Difficolt√† dinamica (basata su difficolt√† scelta)
    let obstacleGap = OBSTACLE_GAP_DEFAULT;
    let obstacleSpeed = OBSTACLE_SPEED_DEFAULT;
    let baseObstacleGap = OBSTACLE_GAP_DEFAULT;
    let baseObstacleSpeed = OBSTACLE_SPEED_DEFAULT;
    let diffScale = 1.0; // modifica quanto la difficolt√† cresce col punteggio
    const DIFFICULTIES = {
        'facile':   { gap: 400, speed: 1.18, gravity: 0.18, dynamicScale: 0.60, desc: 'Gap molto ampio, ostacoli lenti, Chico leggero.' },
        'normale':  { gap: 340, speed: 1.55, gravity: 0.23, dynamicScale: 0.82, desc: 'Esperienza bilanciata e accessibile.' },
        'difficile':{ gap: 270, speed: 2.15, gravity: 0.29, dynamicScale: 1.08, desc: 'Gap stretto, Chico pi√π pesante, ma meno punitivo.' }
    };
    let currentDifficulty = 'normale';
    let difficultyChosen = false;
        let obstacles = [];

        // Bottiglie di rum
    const BOTTLE_RADIUS = 16;
    let bottles = [];
    // Power-up: Scudo (invincibilit√† per un colpo)
    const SHIELD_RADIUS = 18;
    let shieldItems = [];
    let hasShield = false;
    // Stato visivo / invulnerabilit√† scudo
    let shieldBreakingEnd = 0; // fine anim rottura
    let shieldInvulnUntil = 0; // invuln attiva mentre scudo integro o in rottura
    let shieldCharges = 0;
    const SHIELD_HITS = 1;
    let lastShieldSpawnScore = 0;
    const SHIELD_MIN_SCORE_GAP = 4;
    const SHIELD_SPAWN_CHANCE = 0.5; // probabilit√† per frame
    const SHIELD_BREAK_DURATION = 600; // ms animazione rottura (invulnerabile)
        // Particelle scintille
        let particles = [];
    // --- Munizioni & proiettili (chicchi di mais) ---
    const MAX_AMMO = 3;
    let ammo = MAX_AMMO;
    let projectiles = []; // {x,y,vx,vy,r}
    // Corn pickups (pannocchie)
    const CORN_RADIUS = 18;
    let cornItems = []; // {x,y,collected:false}
    let lastCornSpawnScore = 0;
    const CORN_MIN_SCORE_GAP = 5; // distanza minima in punteggio prima di poter spawnare una nuova pannocchia
    const CORN_SPAWN_CHANCE = 0.35; // probabilit√† per frame quando eleggibile
        // Parallax: navi/isole
        const parallaxElements = [
            {x: 70, y: 420, w: 90, h: 40, type: 'island'},
            {x: 320, y: 545, w: 70, h: 30, type: 'ship'} 
        ];
        // --- Nuvole di sfondo (alto) ---
        // --- Sistema nuvole migliorato (multi-layer con profondit√†, gradienti e variazioni) ---
        // Nuvole pi√π grandi, dense e scenografiche
        const CLOUD_LAYER_CONFIG = [
            { id:0, weight:0.28, speed:[0.04,0.08], scale:[0.75,1.05], alpha:0.50, y:[-35,25],   blur:7 },   // lontane, grandi (ancora pi√π in alto)
            { id:1, weight:0.48, speed:[0.09,0.16], scale:[1.05,1.35], alpha:0.80, y:[-10,60],    blur:10 },  // medie, molto grandi (ancora pi√π in alto)
            { id:2, weight:0.24, speed:[0.15,0.26], scale:[1.3,1.65], alpha:0.92, y:[10,100],    blur:14 }   // vicine, enormi (ancora pi√π in alto)
        ];
    const TOTAL_CLOUDS = 7; // ridotto per performance
    let clouds = [];
    // Ottimizzazione: pre-rendering nuvole
    let cloudCanvases = [];
    let cloudFrameSkip = 0;
        function pickLayer() {
            const r = Math.random();
            let acc = 0;
            for (const cfg of CLOUD_LAYER_CONFIG) { acc += cfg.weight; if (r <= acc) return cfg; }
            return CLOUD_LAYER_CONFIG[CLOUD_LAYER_CONFIG.length-1];
        }
        function createCloud(x, layerCfg) {
            const cfg = layerCfg || pickLayer();
            const scale = cfg.scale[0] + Math.random() * (cfg.scale[1]-cfg.scale[0]);
            const baseW = 150, baseH = 48;
            const w = baseW * scale * (0.95 + Math.random()*0.5);
            const h = baseH * scale * (0.75 + Math.random()*0.35);
            const y = cfg.y[0] + Math.random() * (cfg.y[1]-cfg.y[0]);
            const speed = cfg.speed[0] + Math.random() * (cfg.speed[1]-cfg.speed[0]);
            const lobes = 4 + Math.floor(Math.random()*2); // 4-5
            const lobeData = [];
            const spacing = w / (lobes + 1);
            for (let i=0;i<lobes;i++) {
                const lx = -w/2 + spacing*(i+1);
                const ly = (Math.random()*0.5 - 0.25) * h * 0.35;
                const rw = spacing * (0.95 + Math.random()*0.25) * (0.85 + (i%2)*0.12);
                const rh = h * (0.28 + Math.random()*0.22);
                lobeData.push({ lx, ly, rw, rh });
            }
            // Pre-render cloud
            const off = document.createElement('canvas');
            off.width = Math.ceil(w+24); off.height = Math.ceil(h+24);
            const offCtx = off.getContext('2d');
            offCtx.save();
            offCtx.translate(off.width/2, off.height/2);
            offCtx.globalAlpha = cfg.alpha;
            // Forma
            offCtx.beginPath();
            for (let i=0;i<lobeData.length;i++) {
                const L = lobeData[i];
                offCtx.ellipse(L.lx, L.ly, L.rw, L.rh, 0, 0, Math.PI*2);
            }
            // Gradiente volumetrico
            const gradBody = offCtx.createLinearGradient(-w/2, -h/2, w/2, h/2);
            gradBody.addColorStop(0, 'rgba(255,255,255,0.96)');
            gradBody.addColorStop(0.55, 'rgba(240,245,255,0.88)');
            gradBody.addColorStop(1, 'rgba(210,225,245,0.72)');
            offCtx.fillStyle = gradBody;
            // offCtx.shadowColor = 'rgba(255,255,255,0.9)';
            // offCtx.shadowBlur = cfg.blur; // ombra rimossa per performance
            offCtx.fill();
            // Ombra inferiore / retro
            offCtx.globalCompositeOperation = 'source-atop';
            const shade = offCtx.createLinearGradient(0,-h/2,0,h/2);
            shade.addColorStop(0,'rgba(0,0,0,0)');
            shade.addColorStop(0.55,'rgba(0,0,0,0)');
            shade.addColorStop(1,'rgba(0,0,0,0.13)');
            offCtx.fillStyle = shade;
            offCtx.fill();
            // Highlight direzionale
            offCtx.globalCompositeOperation = 'lighter';
            const rimR = Math.min(w, h) * 0.22;
            const hx = -w/4 - (-0.6) * 6;
            const hy = -h/4 - (-0.8) * 6;
            const highlight = offCtx.createRadialGradient(hx, hy, rimR*0.1, hx, hy, rimR);
            highlight.addColorStop(0,'rgba(255,255,255,0.7)');
            highlight.addColorStop(1,'rgba(255,255,255,0)');
            offCtx.beginPath();
            offCtx.ellipse(hx, hy, rimR, rimR*0.7, 0, 0, Math.PI*2);
            offCtx.fillStyle = highlight;
            offCtx.fill();
            offCtx.restore();
            return { x, y, w, h, speed, lobes, lobeData, layer: cfg.id, alpha: cfg.alpha, blur: cfg.blur, scale, offscreen: off };
        }
        function resetClouds() {
            clouds = [];
            // Distribuisci lungo l'asse X tenendo conto della densit√†
            for (let i=0;i<TOTAL_CLOUDS;i++) {
                const cfg = pickLayer();
                const gap = 120 + Math.random()*180;
                const x = i===0 ? 0 : (clouds[i-1].x + gap);
                clouds.push(createCloud(x, cfg));
            }
        }
        function recycleCloud(c) {
            const lastX = clouds.reduce((m,cl)=> Math.max(m, cl.x + cl.w*0.5), -Infinity);
            const cfg = pickLayer();
            const nc = createCloud(Math.max(canvas.width+100, lastX + 120 + Math.random()*160), cfg);
            Object.assign(c, nc);
        }
        function drawClouds() {
            // Frame skipping: aggiorna solo ogni 2 frame
            cloudFrameSkip = (cloudFrameSkip+1)%2;
            if (cloudFrameSkip===0) {
                for (let c of clouds) {
                    c.x -= c.speed;
                    if (c.x + c.w < -80) {
                        recycleCloud(c);
                    }
                }
            }
            // Ordina per layer solo quando necessario (non ogni frame)
            // clouds.sort((a,b)=> a.layer - b.layer); // disabilitato per performance
            for (let c of clouds) {
                ctx.save();
                ctx.globalAlpha = c.alpha;
                ctx.drawImage(c.offscreen, c.x, c.y);
                ctx.restore();
            }
        }
        function drawParallax() {
            for (let elem of parallaxElements) {
                ctx.save();
                if (elem.type === 'island') {
                    ctx.fillStyle = '#e2c97b';
                    ctx.beginPath();
                    ctx.ellipse(elem.x, elem.y, elem.w/2, elem.h/2, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.ellipse(elem.x, elem.y-elem.h/2+8, elem.w/3, elem.h/4, 0, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    // nave stilizzata con teschio sulla vela e scritta "DNAS" sullo scafo
                    const hullX = elem.x - elem.w/2;
                    const hullY = elem.y;
                    const hullW = elem.w;
                    const hullH = elem.h/2;

                    // Scafo
                    ctx.fillStyle = '#8B5A2B';
                    ctx.fillRect(hullX, hullY, hullW, hullH);

                    // Vela (triangolo bianco)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(elem.x, elem.y);
                    ctx.lineTo(elem.x + elem.w/4, elem.y - elem.h/2);
                    ctx.lineTo(elem.x - elem.w/4, elem.y - elem.h/2);
                    ctx.closePath();
                    ctx.fill();

                    // Teschio nero sulla vela (centro approssimato della vela)
                    const sailCX = elem.x;
                    const sailCY = elem.y - elem.h/2 + (elem.h * 0.18);
                    const skullR = Math.max(4, Math.min(8, Math.floor(elem.h * 0.18)));
                    // testa
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(sailCX, sailCY, skullR, 0, Math.PI * 2);
                    ctx.fill();
                    // mandibola
                    ctx.beginPath();
                    ctx.moveTo(sailCX - skullR * 0.7, sailCY + skullR * 0.5);
                    ctx.quadraticCurveTo(sailCX, sailCY + skullR * 1.1, sailCX + skullR * 0.7, sailCY + skullR * 0.5);
                    ctx.lineTo(sailCX - skullR * 0.7, sailCY + skullR * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    // occhi (fori bianchi)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(sailCX - skullR * 0.35, sailCY - skullR * 0.2, skullR * 0.22, 0, Math.PI * 2);
                    ctx.arc(sailCX + skullR * 0.35, sailCY - skullR * 0.2, skullR * 0.22, 0, Math.PI * 2);
                    ctx.fill();
                    // naso (triangolino)
                    ctx.beginPath();
                    ctx.moveTo(sailCX, sailCY + skullR * 0.05);
                    ctx.lineTo(sailCX - skullR * 0.12, sailCY + skullR * 0.35);
                    ctx.lineTo(sailCX + skullR * 0.12, sailCY + skullR * 0.35);
                    ctx.closePath();
                    ctx.fill();

                    // Scritta "DNAS" sullo scafo
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.max(8, Math.floor(hullH * 0.6))}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('DNAS', hullX + hullW / 2, hullY + hullH / 2 + 1);
                }
                ctx.restore();
            }
            // --- Mare in basso (parallax animato) ---
            drawSeaParallax();
        }

        // Mare: onde che scorrono orizzontalmente
        // Ottimizzazione: frame skipping onde del mare
        let seaFrameSkip = 0;
        let seaCache = null, seaCacheTime = 0;
        function drawSeaParallax() {
            seaFrameSkip = (seaFrameSkip+1)%3;
            const now = Date.now();
            if (seaFrameSkip===0 || !seaCache || now-seaCacheTime>120) {
                // Redraw sea
                const t = now / 1000;
                const baseY = canvas.height - 38;
                const h = 38;
                const waveLen = 110;
                const amp = 7;
                const speed = 32;
                const off = document.createElement('canvas');
                off.width = canvas.width; off.height = h+8;
                const offCtx = off.getContext('2d');
                offCtx.globalAlpha = 0.82;
                offCtx.beginPath();
                for (let x = 0; x <= canvas.width+2; x += 2) {
                    const y = 8 + Math.sin((x + t*speed) / waveLen) * amp + Math.sin((x - t*speed*0.7) / (waveLen*0.6)) * 2.5;
                    if (x === 0) offCtx.moveTo(x, y);
                    else offCtx.lineTo(x, y);
                }
                offCtx.lineTo(canvas.width, h+8);
                offCtx.lineTo(0, h+8);
                offCtx.closePath();
                const grad = offCtx.createLinearGradient(0, 8, 0, h+8);
                grad.addColorStop(0, '#b3e6ff');
                grad.addColorStop(0.5, '#5ec6e6');
                grad.addColorStop(1, 'rgba(0,80,180,0.85)');
                offCtx.fillStyle = grad;
                // offCtx.shadowColor = '#b3e6ff'; // ombra rimossa
                // offCtx.shadowBlur = 0;
                offCtx.fill();
                offCtx.globalAlpha = 1;
                offCtx.beginPath();
                for (let x = 0; x <= canvas.width+2; x += 4) {
                    const y = 8 + Math.sin((x + t*speed) / waveLen) * amp - 2;
                    if (x === 0) offCtx.moveTo(x, y);
                    else offCtx.lineTo(x, y);
                }
                offCtx.strokeStyle = 'rgba(255,255,255,0.32)';
                offCtx.lineWidth = 2.2;
                // offCtx.shadowColor = 'rgba(255,255,255,0.18)';
                // offCtx.shadowBlur = 0;
                offCtx.stroke();
                seaCache = off;
                seaCacheTime = now;
            }
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.drawImage(seaCache, 0, canvas.height-38);
            ctx.restore();
        }

        function drawHintOverlay() {
            if (!showHint) return;
            const w = canvas.width * 0.8;
            const h = 90;
            const x = (canvas.width - w) / 2;
            const y = canvas.height * 0.35;

            ctx.save();
            // pannello semitrasparente
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);

            // testo
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('TAP per volare', canvas.width/2, y + h/2 - 8);
            ctx.font = '14px Arial';
            ctx.fillText('Raccogli RUM per fare punti', canvas.width/2, y + h/2 + 16);
            ctx.restore();
        }

        function isSafeStartActive() {
            return Date.now() < safeStartEndTime;
        }

        // Ottimizzazione: frame skipping particelle
        let particleFrameSkip = 0;
        function drawParticles() {
            particleFrameSkip = (particleFrameSkip+1)%2;
            for (let i = particles.length-1; i >= 0; i--) {
                let p = particles[i];
                if (particleFrameSkip===0) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                }
                ctx.save();
                ctx.globalAlpha = Math.max(0, p.life/20);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fillStyle = p.color;
                // ctx.shadowColor = p.color; // ombra rimossa
                // ctx.shadowBlur = 0;
                ctx.fill();
                ctx.restore();
                if (p.life <= 0) particles.splice(i,1);
            }
        }

        // Ottimizzazione: meno particelle
        function spawnParticles(x, y, color='#ffd700') {
            for (let i=0; i<6; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random()-0.5)*2.2,
                    vy: (Math.random()-0.5)*2.2,
                    size: 2+Math.random()*2,
                    color,
                    life: 14+Math.random()*6
                });
            }
        }

        // Ostacoli volanti (barili volanti e gabbiani)
        const FLYING_OBSTACLE_WIDTH = 48;
        const FLYING_OBSTACLE_HEIGHT = 36;
    const FLYING_OBSTACLE_SPEED = 2.8;
        let flyingObstacles = [];


        // --- Game Platform: invia punteggio a Telegram ---
        function telegramShareScore(score) {
            if (window.TelegramGameProxy && typeof TelegramGameProxy.shareScore === 'function') {
                TelegramGameProxy.shareScore(score);
            }
        }

        // Musica di sottofondo (avvio al primo TAP)
        const MUSIC_URL = 'https://noncolpito.github.io/DNASound/dnas.mp3'; // link mp3
        let bgm = null;
        let isMuted = false;
        function setupBgm(url) {
            if (bgm) return;
            try {
                bgm = new Audio(url);
                bgm.loop = true;
                bgm.volume = 0.3; // regola volume musica
                bgm.preload = 'auto';
            } catch (_) { /* no-op */ }
        }
        function ensureBgmPlaying() {
            if (!bgm || isMuted) return;
            const p = bgm.play();
            if (p && typeof p.catch === 'function') p.catch(() => {});
        }
        function toggleMute() {
            const btn = document.getElementById('muteBtn');
            isMuted = !isMuted;
            if (bgm) {
                bgm.muted = isMuted;
                if (isMuted) {
                    bgm.pause();
                } else {
                    ensureBgmPlaying();
                }
            }
            btn.textContent = isMuted ? 'üîá' : 'üîä';
        }


        function resetObstacles() {
            obstacles = [createObstacle(canvas.width)];
        }
        function createObstacle(x) {
            // Usa l'obstacleGap attuale come ampiezza per questo ostacolo (cos√¨ resta consistente se la difficolt√† cambia dopo)
            const gapSize = obstacleGap;
            const minGap = 60;
            const maxGap = canvas.height - 60 - gapSize;
            const gapY = Math.floor(Math.random() * (maxGap - minGap + 1)) + minGap;
            return { x: x, gapY: gapY, gap: gapSize, passed: false };
        }

        function resetBottles() {
            bottles = [createBottle(canvas.width + 200)];
        }
        function createBottle(x) {
            const minY = 80;
            const maxY = canvas.height - 80;
            let y;
            if (obstacles.length) {
                const last = obstacles[obstacles.length - 1];
                const target = last.gapY + obstacleGap / 2;
                const spread = obstacleGap * 0.6;
                y = target + (Math.random() - 0.5) * spread;
                y = Math.max(minY, Math.min(maxY, y));
            } else {
                y = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
            }
            return { x: x, y: y, collected: false };
        }

        function resetFlyingObstacles() {
            flyingObstacles = [createFlyingObstacle(canvas.width + 100)];
        }
        function createFlyingObstacle(x) {
            const type = Math.random() < 0.5 ? 'barile' : 'gabbiano';
            const minY = 60;
            const maxY = canvas.height - 200;
            const y = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
            return { x: x, y: y, type: type, passed: false };
        }
// Ottimizzazione: frame skipping ali/gabbiani
let birdWingFrameSkip = 0;
function drawFlyingObstacle(obs) {
    ctx.save();
    if (obs.type === 'barile') {
        ctx.save();
        ctx.beginPath();
        ctx.ellipse(obs.x + FLYING_OBSTACLE_WIDTH/2, obs.y + FLYING_OBSTACLE_HEIGHT/2, FLYING_OBSTACLE_WIDTH/2, FLYING_OBSTACLE_HEIGHT/2, 0, 0, Math.PI * 2);
        ctx.fillStyle = '#a0522d';
        // ctx.shadowColor = '#654321'; // ombra rimossa
        // ctx.shadowBlur = 0;
        ctx.fill();
        // Doghe
        ctx.strokeStyle = '#8B5A2B';
        ctx.lineWidth = 2;
        for (let i = 1; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(obs.x + i * FLYING_OBSTACLE_WIDTH/4, obs.y + 6);
            ctx.lineTo(obs.x + i * FLYING_OBSTACLE_WIDTH/4, obs.y + FLYING_OBSTACLE_HEIGHT - 6);
            ctx.stroke();
        }
        // Anelli metallici
        ctx.strokeStyle = '#bbb';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(obs.x + FLYING_OBSTACLE_WIDTH/2, obs.y + 8, FLYING_OBSTACLE_WIDTH/2.1, 5, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(obs.x + FLYING_OBSTACLE_WIDTH/2, obs.y + FLYING_OBSTACLE_HEIGHT - 8, FLYING_OBSTACLE_WIDTH/2.1, 5, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    } else {
        ctx.save();
        const cx = obs.x + FLYING_OBSTACLE_WIDTH/2;
        const cy = obs.y + FLYING_OBSTACLE_HEIGHT/2;
        // Corpo con gradiente
        const bodyGrad = ctx.createLinearGradient(cx - 12, cy - 10, cx + 12, cy + 10);
        bodyGrad.addColorStop(0, '#f6f6f6');
        bodyGrad.addColorStop(1, '#d9d9d9');
        ctx.beginPath();
        ctx.ellipse(cx, cy, 16, 10, Math.PI/14, 0, Math.PI * 2);
        ctx.fillStyle = bodyGrad;
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.stroke();
        // Testa
        const headGrad = ctx.createRadialGradient(cx + 10, cy - 4, 1, cx + 8, cy - 4, 6);
        headGrad.addColorStop(0, '#ffffff');
        headGrad.addColorStop(1, '#e8e8e8');
        ctx.beginPath();
        ctx.arc(cx + 8, cy - 2, 6, 0, Math.PI * 2);
        ctx.fillStyle = headGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.12)';
        ctx.stroke();
        // Becco (superiore/inferiore) con sfumatura
        const beakGrad = ctx.createLinearGradient(cx + 12, cy - 4, cx + 24, cy + 2);
        beakGrad.addColorStop(0, '#ffd16a');
        beakGrad.addColorStop(1, '#ffae00');
        ctx.beginPath();
        ctx.moveTo(cx + 12, cy - 2);
        ctx.quadraticCurveTo(cx + 20, cy - 6, cx + 24, cy - 1);
        ctx.lineTo(cx + 13, cy - 1);
        ctx.closePath();
        ctx.fillStyle = beakGrad;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(cx + 12, cy - 1);
        ctx.quadraticCurveTo(cx + 19, cy + 2, cx + 23, cy + 1);
        ctx.lineTo(cx + 13, cy + 1);
        ctx.closePath();
        ctx.fillStyle = '#ffae00';
        ctx.fill();
        // Occhio con riflesso
        ctx.beginPath();
        ctx.arc(cx + 9, cy - 3, 1.6, 0, Math.PI * 2);
        ctx.fillStyle = '#111';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(cx + 9.6, cy - 3.4, 0.5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fill();
        // Ali animate (frame skipping)
        birdWingFrameSkip = (birdWingFrameSkip+1)%2;
        let wingAngle = 0;
        if (birdWingFrameSkip===0) {
            const t = Date.now();
            wingAngle = Math.sin((t + obs.x * 30) / 180) * 0.6;
            obs._wingAngle = wingAngle;
        } else if (typeof obs._wingAngle !== 'undefined') {
            wingAngle = obs._wingAngle;
        }
        // Ala posteriore
        ctx.save();
        ctx.translate(cx - 6, cy - 2);
        ctx.rotate(-0.15 - wingAngle * 0.8);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-16, -8, -28, 0);
        ctx.quadraticCurveTo(-16, 6, 0, 0);
        ctx.fillStyle = 'rgba(210,210,210,0.7)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.12)';
        ctx.stroke();
        ctx.restore();
        // Ala anteriore
        ctx.save();
        ctx.translate(cx - 6, cy - 2);
        ctx.rotate(0.15 + wingAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-18, -10, -30, -2);
        ctx.quadraticCurveTo(-16, 8, 0, 0);
        ctx.fillStyle = '#e6e6e6';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.stroke();
        ctx.restore();
        // Coda
        ctx.beginPath();
        ctx.moveTo(cx - 12, cy + 2);
        ctx.lineTo(cx - 18, cy + 1);
        ctx.lineTo(cx - 16, cy + 5);
        ctx.closePath();
        ctx.fillStyle = '#dcdcdc';
        ctx.fill();
        ctx.restore();
    }
    ctx.restore();
}
// ====== Proiettili (chicchi di mais) ======
function fire() {
    if (!hasStarted || gameOver) return;
    if (ammo <= 0) return;
    ammo--;
    // posiziona proiettile davanti a Chico
    const px = 80 + CHICO_RADIUS - 4;
    const py = chicoY;
    // AUTO-MIRA: cerca il bersaglio volante pi√π vicino in avanti
    let target = null;
    let bestDist = Infinity;
    const shooterX = px;
    for (const fo of flyingObstacles) {
        const cx = fo.x + FLYING_OBSTACLE_WIDTH/2;
        const cy = fo.y + FLYING_OBSTACLE_HEIGHT/2;
        // Considera solo quelli davanti a Chico
        if (cx <= shooterX) continue;
        const dx = cx - shooterX;
        const dy = cy - py;
        const dist = Math.hypot(dx, dy);
        if (dist < bestDist) {
            bestDist = dist;
            target = { cx, cy };
        }
    }
    // Se nessun bersaglio volante, come fallback mira dritto
    const SPEED = 7.2; // velocit√† proiettile
    let vx = 6.2, vy = 0; // default
    if (target) {
        let dx = target.cx - shooterX;
        let dy = target.cy - py;
        const len = Math.hypot(dx, dy) || 1;
        vx = (dx / len) * SPEED;
        vy = (dy / len) * SPEED;
        // assicura che vada comunque avanti abbastanza velocemente
        if (vx < 3) {
            const boost = 3 - vx;
            const scale = (SPEED + boost) / SPEED;
            vx *= scale;
            vy *= scale;
        }
    }
    projectiles.push({ x: px, y: py, vx, vy, r: 6, born: Date.now(), target });
    spawnParticles(px, py, '#ffd34d');
}
function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        // Se ha un target e esiste ancora qualche ostacolo volante, ritocca la mira (leggera homing)
        if (p.target) {
            // trova ostacolo pi√π vicino alla posizione target memorizzata (o aggiorna se manca)
            let closest = null;
            let best = Infinity;
            for (const fo of flyingObstacles) {
                const cx = fo.x + FLYING_OBSTACLE_WIDTH/2;
                const cy = fo.y + FLYING_OBSTACLE_HEIGHT/2;
                if (cx < p.x) continue; // ignora quelli ormai dietro al proiettile
                const d = Math.hypot(cx - p.x, cy - p.y);
                if (d < best) { best = d; closest = { cx, cy }; }
            }
            if (closest) {
                // interpolazione verso il nuovo vettore
                const SPEED = Math.hypot(p.vx, p.vy) || 7.2;
                let dx = closest.cx - p.x;
                let dy = closest.cy - p.y;
                const len = Math.hypot(dx, dy) || 1;
                dx /= len; dy /= len;
                // blending per non cambiare direzione troppo bruscamente
                const blend = 0.18; // 0=no homing, 1=aggancio totale
                const curLen = Math.hypot(p.vx, p.vy) || SPEED;
                let curdx = p.vx / curLen;
                let curdy = p.vy / curLen;
                const ndx = curdx*(1-blend) + dx*blend;
                const ndy = curdy*(1-blend) + dy*blend;
                p.vx = ndx * SPEED;
                p.vy = ndy * SPEED;
            }
        }
        p.x += p.vx;
        p.y += p.vy;
        // disegna
        ctx.save();
        ctx.translate(p.x, p.y);
        const g = ctx.createRadialGradient(0,0,1,0,0,p.r);
        g.addColorStop(0,'#fffacd');
        g.addColorStop(0.4,'#ffe066');
        g.addColorStop(1,'#d48806');
        ctx.beginPath();
        ctx.arc(0,0,p.r,0,Math.PI*2);
        ctx.fillStyle = g;
        ctx.shadowColor = '#ffef9a';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.restore();
        // collisione con ostacoli volanti
        for (let j = flyingObstacles.length - 1; j >= 0; j--) {
            const fo = flyingObstacles[j];
            if (p.x + p.r > fo.x && p.x - p.r < fo.x + FLYING_OBSTACLE_WIDTH && p.y + p.r > fo.y && p.y - p.r < fo.y + FLYING_OBSTACLE_HEIGHT) {
                // distruggi ostacolo
                spawnParticles(fo.x + FLYING_OBSTACLE_WIDTH/2, fo.y + FLYING_OBSTACLE_HEIGHT/2, '#ffcf4d');
                flyingObstacles.splice(j,1);
                projectiles.splice(i,1);
                break;
            }
        }
        // rimuovi se fuori schermo
    const TTL = 4000; // ms
    if (projectiles[i] && ((p.x - p.r > canvas.width + 40) || Date.now() - p.born > TTL)) {
            projectiles.splice(i,1);
        }
    }
}

// ====== Corn pickup (pannocchia) ======
function spawnCornMaybe() {
    if (!hasStarted || gameOver) return;
    if (score - lastCornSpawnScore < CORN_MIN_SCORE_GAP) return;
    if (Math.random() < CORN_SPAWN_CHANCE / 60) { // mitigazione frame-rate
        const y = 90 + Math.random() * (canvas.height - 250);
        cornItems.push({ x: canvas.width + 40, y, collected: false });
        lastCornSpawnScore = score;
    }
}
// (Versione semplificata pannocchia)
function drawCornItem(item) {
    ctx.save();
    const bob = Math.sin((Date.now()+ item.x*30)/500)*3;
    ctx.translate(item.x, item.y + bob);
    ctx.beginPath();
    ctx.ellipse(0,0,CORN_RADIUS*0.55,CORN_RADIUS*0.9,0,0,Math.PI*2);
    const grad = ctx.createLinearGradient(0,-CORN_RADIUS,0,CORN_RADIUS);
    grad.addColorStop(0,'#fff59d');
    grad.addColorStop(1,'#f1c40f');
    ctx.fillStyle = grad;
    ctx.strokeStyle = '#c49000';
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();
    ctx.restore();
}

// Ottimizzazione: frame skipping e meno ombre/gradienti su Chico
function drawChico(y) {
    // Unico frame skip globale
    globalFrameSkip = (globalFrameSkip+1)%2;
    // Pre-render key: y, scudo, breaking, wingAngle
    let x = 80;
    let hasScudo = hasShield;
    let breaking = Date.now() < shieldBreakingEnd;
    let wingAngle = 0;
    if (globalFrameSkip===0 || !chicoCache) {
        wingAngle = Math.sin(Date.now() / 120) * 0.5 + (chicoVY < 0 ? -0.7 : 0);
    } else if (chicoCacheKey) {
        wingAngle = chicoCacheKey.wingAngle;
    }
    let cacheKey = JSON.stringify({y:Math.round(y),hasScudo,breaking,wingAngle:Math.round(wingAngle*100)});
    if (chicoCache && chicoCacheKey && chicoCacheKey.key === cacheKey) {
        ctx.drawImage(chicoCache,0,0);
        return;
    }
    // Pre-render Chico
    let off = document.createElement('canvas');
    off.width = canvas.width; off.height = canvas.height;
    let octx = off.getContext('2d');
    // ...existing code for drawing Chico, replace ctx with octx and x/y as above...
    // Aura scudo / flash consumo (ombre ridotte)
    if (hasScudo) {
        octx.save();
        const pulse = 0.6 + Math.sin(Date.now()/180) * 0.25;
        octx.beginPath();
        octx.arc(x, y, CHICO_RADIUS + 14 + pulse * 4, 0, Math.PI * 2);
        octx.strokeStyle = 'rgba(160,230,255,0.5)';
        octx.lineWidth = 2;
        octx.stroke();
        octx.restore();
    } else if (breaking) {
        const remain = (shieldBreakingEnd - Date.now()) / SHIELD_BREAK_DURATION;
        const rings = 2;
        for (let i=0;i<rings;i++) {
            const ratio = i / rings;
            const alpha = Math.max(0,(remain - ratio*0.25))*0.6;
            if (alpha <= 0) continue;
            octx.save();
            const r = CHICO_RADIUS + 12 + ratio*28 + Math.sin(Date.now()/90 + i)*2;
            octx.globalAlpha = alpha;
            octx.beginPath();
            octx.arc(x, y, r, 0, Math.PI*2);
            octx.strokeStyle = 'rgba(150,220,255,0.5)';
            octx.lineWidth = 1.5 + (1-remain)*1.5;
            octx.stroke();
            octx.restore();
        }
    }
    // Corpo (rosso) con gradiente e contorno
    const bodyGrad = octx.createRadialGradient(x - 6, y - 8, CHICO_RADIUS * 0.2, x, y, CHICO_RADIUS);
    bodyGrad.addColorStop(0, '#ff3b30');
    bodyGrad.addColorStop(1, '#8c0000');
    octx.beginPath();
    octx.arc(x, y, CHICO_RADIUS, 0, Math.PI * 2);
    octx.fillStyle = bodyGrad;
    octx.fill();
    octx.lineWidth = 1.2;
    octx.strokeStyle = '#7a0000';
    octx.stroke();
    // Pancia (giallo-oro) con gradiente
    const bellyGrad = octx.createRadialGradient(x, y + 10, CHICO_RADIUS * 0.2, x, y + 10, CHICO_RADIUS * 0.7);
    bellyGrad.addColorStop(0, '#ffe680');
    bellyGrad.addColorStop(1, '#d4b200');
    octx.beginPath();
    octx.arc(x, y + 10, CHICO_RADIUS * 0.7, 0, Math.PI * 2);
    octx.fillStyle = bellyGrad;
    octx.fill();
    // Coda a piume (rosso, giallo, blu)
    octx.save();
    octx.translate(x, y + CHICO_RADIUS - 2);
    octx.rotate(Math.PI / 8);
    const tailColors = ['#ff3b30', '#ffd700', '#0078ff'];
    for (let i = 0; i < tailColors.length; i++) {
        octx.beginPath();
        octx.moveTo(-2 - i * 2, 0);
        octx.quadraticCurveTo(-16 - i * 4, 16 + i * 2, -2 - i * 2, 28 + i * 2);
        octx.quadraticCurveTo(2 - i, 20 + i * 2, -2 - i * 2, 0);
        octx.fillStyle = tailColors[i];
        octx.globalAlpha = 0.9 - i * 0.15;
        octx.fill();
    }
    octx.globalAlpha = 1;
    octx.restore();
    // Piume decorative rosse
    for (let i = 0; i < 3; i++) {
        octx.save();
        octx.translate(x, y);
        octx.rotate(Math.PI / 7 * i);
        octx.beginPath();
        octx.moveTo(-CHICO_RADIUS + 6, -6);
        octx.quadraticCurveTo(-CHICO_RADIUS - 6, -10, -CHICO_RADIUS + 1, -1);
        octx.strokeStyle = '#ff5a5f';
        octx.lineWidth = 1.2;
        octx.stroke();
        octx.restore();
    }
    // Ali animate con gradiente
    for (let i = 0; i < 2; i++) {
        octx.save();
        octx.translate(x, y);
        octx.rotate(wingAngle + i * 0.1);
        const cx = -18, cy = i * 2, rx = 18 - i * 2, ry = 8;
        const wingGrad = octx.createRadialGradient(cx - 6, cy - 4, 2, cx, cy, rx);
        wingGrad.addColorStop(0, '#ff6666');
        wingGrad.addColorStop(1, '#b10000');
        octx.beginPath();
        octx.ellipse(cx, cy, rx, ry, Math.PI / 4, 0, Math.PI * 2);
        octx.fillStyle = wingGrad;
        octx.globalAlpha = 0.78 - i * 0.18;
        octx.fill();
        octx.globalAlpha = 1;
        octx.lineWidth = 1;
        octx.strokeStyle = 'rgba(122,0,0,0.6)';
        octx.stroke();
        octx.restore();
    }
    // Becco
    octx.save();
    octx.beginPath();
    octx.moveTo(x + CHICO_RADIUS, y - 6);
    octx.quadraticCurveTo(x + CHICO_RADIUS + 10, y - 10, x + CHICO_RADIUS + 18, y - 2);
    octx.lineTo(x + CHICO_RADIUS + 1, y - 2);
    octx.closePath();
    octx.fillStyle = '#ffb347';
    octx.fill();
    octx.beginPath();
    octx.moveTo(x + CHICO_RADIUS, y - 2);
    octx.quadraticCurveTo(x + CHICO_RADIUS + 10, y + 5, x + CHICO_RADIUS + 16, y + 2);
    octx.lineTo(x + CHICO_RADIUS, y + 4);
    octx.closePath();
    octx.fillStyle = '#ff9e2c';
    octx.fill();
    octx.beginPath();
    octx.moveTo(x + CHICO_RADIUS + 2, y);
    octx.quadraticCurveTo(x + CHICO_RADIUS + 8, y + 2, x + CHICO_RADIUS + 14, y + 1);
    octx.strokeStyle = 'rgba(120,60,0,0.5)';
    octx.lineWidth = 1;
    octx.stroke();
    octx.restore();
    // Orecchino d'oro
    octx.beginPath();
    octx.arc(x + 4, y + CHICO_RADIUS / 2, 4, 0, Math.PI * 2);
    octx.fillStyle = '#ffd700';
    octx.fill();
    octx.strokeStyle = '#9b7500';
    octx.lineWidth = 1;
    octx.stroke();
    // Occhio con bordo e riflessi
    octx.beginPath();
    octx.arc(x + 14, y - 8, 6, 0, Math.PI * 2);
    octx.fillStyle = 'white';
    octx.fill();
    octx.strokeStyle = 'rgba(0,0,0,0.6)';
    octx.lineWidth = 1;
    octx.stroke();
    octx.beginPath();
    octx.arc(x + 16, y - 8, 2.2, 0, Math.PI * 2);
    octx.fillStyle = 'black';
    octx.fill();
    octx.beginPath();
    octx.arc(x + 12, y - 10, 2, 0, Math.PI * 2);
    octx.fillStyle = 'rgba(255,255,255,0.9)';
    octx.fill();
    octx.beginPath();
    octx.arc(x + 17.5, y - 6.5, 0.8, 0, Math.PI * 2);
    octx.fillStyle = 'rgba(255,255,255,0.7)';
    octx.fill();
    // Benda da pirata
    octx.save();
    octx.strokeStyle = '#222';
    octx.lineWidth = 3;
    octx.beginPath();
    octx.arc(x + 14, y - 8, 6, Math.PI * 0.2, Math.PI * 0.8);
    octx.stroke();
    octx.beginPath();
    octx.moveTo(x + 20, y - 13);
    octx.quadraticCurveTo(x + 25, y - 10, x + 22, y - 5);
    octx.strokeStyle = '#222';
    octx.lineWidth = 2;
    octx.stroke();
    octx.restore();
    // Cappello da pirata (ombre ridotte)
    octx.save();
    const hatGrad = octx.createLinearGradient(x + 2, y - CHICO_RADIUS - 18, x + 34, y - CHICO_RADIUS + 8);
    hatGrad.addColorStop(0, '#111');
    hatGrad.addColorStop(1, '#2a2a2a');
    octx.beginPath();
    octx.moveTo(x + 2, y - CHICO_RADIUS - 2);
    octx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 18, x + 34, y - CHICO_RADIUS + 6);
    octx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 8, x + 2, y - CHICO_RADIUS - 2);
    octx.closePath();
    octx.fillStyle = hatGrad;
    octx.fill();
    octx.beginPath();
    octx.moveTo(x + 2, y - CHICO_RADIUS - 2);
    octx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 18, x + 34, y - CHICO_RADIUS + 6);
    octx.strokeStyle = '#ffd700';
    octx.lineWidth = 1.5;
    octx.stroke();
    octx.beginPath();
    octx.moveTo(x + 8, y - CHICO_RADIUS - 8);
    octx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 14, x + 28, y - CHICO_RADIUS - 2);
    octx.strokeStyle = 'rgba(255,255,255,0.10)';
    octx.lineWidth = 1.2;
    octx.stroke();
    octx.beginPath();
    octx.arc(x + 18, y - CHICO_RADIUS - 8, 5, 0, Math.PI * 2);
    octx.fillStyle = 'white';
    octx.fill();
    octx.beginPath();
    octx.arc(x + 16, y - CHICO_RADIUS - 8, 1, 0, Math.PI * 2);
    octx.arc(x + 20, y - CHICO_RADIUS - 8, 1, 0, Math.PI * 2);
    octx.fillStyle = 'black';
    octx.fill();
    octx.beginPath();
    octx.moveTo(x + 15, y - CHICO_RADIUS - 5);
    octx.quadraticCurveTo(x + 18, y - CHICO_RADIUS - 3, x + 21, y - CHICO_RADIUS - 5);
    octx.strokeStyle = 'black';
    octx.lineWidth = 1;
    octx.stroke();
    octx.restore();
    chicoCache = off;
    chicoCacheKey = {key: cacheKey, wingAngle};
    ctx.drawImage(chicoCache,0,0);
}

// --- Power-up Scudo (tridente) ---
function drawShieldItem(item) {
    ctx.save();
    const t = Date.now();
    const bob = Math.sin((t + item.x * 40) / 600) * 4;
    ctx.translate(item.x, item.y + bob);

    const R = SHIELD_RADIUS;

    // Alone soffuso blu
    const aura = ctx.createRadialGradient(0, 0, 6, 0, 0, R + 20);
    aura.addColorStop(0, 'rgba(120,200,255,0.5)');
    aura.addColorStop(0.6, 'rgba(90,170,255,0.25)');
    aura.addColorStop(1, 'rgba(90,170,255,0)');
    ctx.beginPath();
    ctx.arc(0, 0, R + 20, 0, Math.PI * 2);
    ctx.fillStyle = aura;
    ctx.fill();

    // Forma scudo (stile "heater")
    function pathShield(inset = 0) {
        const top = -R * 1.08 + inset;
        const leftX = -R * 0.78 + inset * 0.6;
        const rightX = R * 0.78 - inset * 0.6;
        const midY = R * 0.15 - inset * 0.3;
        const tipY = R * 1.25 - inset;
        ctx.beginPath();
        ctx.moveTo(0, top);
        ctx.quadraticCurveTo(leftX, top + R * 0.45, leftX, midY);
        ctx.quadraticCurveTo(-R * 0.35, R * 0.8, 0, tipY);
        ctx.quadraticCurveTo(R * 0.35, R * 0.8, rightX, midY);
        ctx.quadraticCurveTo(rightX, top + R * 0.45, 0, top);
        ctx.closePath();
    }

    // Corpo blu con bordo metallico
    pathShield(0);
    const bodyGrad = ctx.createLinearGradient(0, -R * 1.1, 0, R * 1.25);
    bodyGrad.addColorStop(0, '#3bb4ff');
    bodyGrad.addColorStop(0.55, '#0d6bd1');
    bodyGrad.addColorStop(1, '#073a7a');
    ctx.fillStyle = bodyGrad;
    ctx.shadowColor = 'rgba(30,120,255,0.45)';
    ctx.shadowBlur = 10;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#d9edff';
    ctx.stroke();

    // Bordo interno leggero
    pathShield(3);
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Riflesso morbido
    ctx.save();
    ctx.beginPath();
    pathShield(0);
    ctx.clip();
    const glare = ctx.createRadialGradient(-R * 0.3, -R * 0.7, 2, -R * 0.3, -R * 0.7, R * 1.2);
    glare.addColorStop(0, 'rgba(255,255,255,0.35)');
    glare.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = glare;
    ctx.fillRect(-R * 2, -R * 2, R * 4, R * 4);
    ctx.restore();

    // Tridente giallo al centro
    ctx.save();
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = '#ffd24a';
    ctx.fillStyle = '#ffd24a';
    ctx.shadowColor = 'rgba(255,210,80,0.55)';
    ctx.shadowBlur = 8;
    const lw = Math.max(2, R * 0.28);
    ctx.lineWidth = lw;

    // Asta centrale
    ctx.beginPath();
    ctx.moveTo(0, R * 0.9);
    ctx.lineTo(0, -R * 0.35);
    ctx.stroke();

    // Punta centrale (triangolo)
    ctx.beginPath();
    ctx.moveTo(0, -R * 1.0);
    ctx.lineTo(-R * 0.18, -R * 0.55);
    ctx.lineTo(R * 0.18, -R * 0.55);
    ctx.closePath();
    ctx.fill();

    // Bracci laterali
    ctx.beginPath();
    ctx.moveTo(0, -R * 0.5);
    ctx.lineTo(-R * 0.42, -R * 0.15);
    ctx.moveTo(0, -R * 0.5);
    ctx.lineTo(R * 0.42, -R * 0.15);
    ctx.stroke();

    // Punte laterali (triangolini)
    ctx.beginPath();
    // sinistra
    ctx.moveTo(-R * 0.42, -R * 0.15);
    ctx.lineTo(-R * 0.58, -R * 0.45);
    ctx.lineTo(-R * 0.28, -R * 0.35);
    ctx.closePath();
    // destra
    ctx.moveTo(R * 0.42, -R * 0.15);
    ctx.lineTo(R * 0.58, -R * 0.45);
    ctx.lineTo(R * 0.28, -R * 0.35);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    ctx.restore();
}
function spawnShieldMaybe() {
    if (hasShield || shieldItems.length>0) return;
    if (score - lastShieldSpawnScore < SHIELD_MIN_SCORE_GAP) return;
    if (hasStarted && Math.random() < SHIELD_SPAWN_CHANCE) {
        const y = 100 + Math.random() * (canvas.height - 220);
        shieldItems.push({ x: canvas.width + 40, y, collected:false });
        lastShieldSpawnScore = score;
    }
}
function consumeShieldEffect() {
    if (!hasShield) return;
    hasShield = false;
    shieldCharges = 0;
    shieldBreakingEnd = Date.now() + SHIELD_BREAK_DURATION;
    shieldInvulnUntil = shieldBreakingEnd; // invulnerabile finch√© dura l'anim di rottura
    spawnParticles(80, chicoY, '#9fdfff');
}

function drawBottle(bottle) {
    ctx.save();
    const bob = Math.sin((Date.now() + bottle.x * 50) / 500) * 3;
    ctx.translate(bottle.x, bottle.y + bob);
    ctx.rotate(-Math.PI/8);

    // Corpo in vetro
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(0, 0, BOTTLE_RADIUS, BOTTLE_RADIUS*1.3, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.stroke();

    // Liquido (rum ambrato)
    ctx.beginPath();
    ctx.ellipse(0, 4, BOTTLE_RADIUS*0.9, BOTTLE_RADIUS*0.9, 0, 0, Math.PI*2);
    ctx.fillStyle = '#c97e2b';
    ctx.globalAlpha = 0.85;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();

    // Collo della bottiglia
    ctx.fillStyle = '#e0e0e0';
    ctx.fillRect(-4, -BOTTLE_RADIUS*1.3-10, 8, 18);
    // Tappo
    ctx.fillStyle = '#5b2b17';
    ctx.fillRect(-6, -BOTTLE_RADIUS*1.3-14, 12, 6);

    // Etichetta con "R"
    ctx.fillStyle = '#fff';
    ctx.fillRect(-10, -2, 20, 12);
    ctx.strokeStyle = '#b33';
    ctx.lineWidth = 1;
    ctx.strokeRect(-10, -2, 20, 12);
    ctx.fillStyle = '#b33';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('R', 0, 4);

    ctx.restore();
}

        function drawObstacle(obs) {
            const gapSize = obs.gap !== undefined ? obs.gap : obstacleGap; // fallback se vecchio oggetto
            ctx.save();
            ctx.fillStyle = '#8B5A2B';
            ctx.fillRect(obs.x, 0, OBSTACLE_WIDTH, obs.gapY);
            ctx.fillRect(obs.x, obs.gapY + gapSize, OBSTACLE_WIDTH, canvas.height - obs.gapY - gapSize);
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 4;
            ctx.strokeRect(obs.x, 0, OBSTACLE_WIDTH, obs.gapY);
            ctx.strokeRect(obs.x, obs.gapY + gapSize, OBSTACLE_WIDTH, canvas.height - obs.gapY - gapSize);
            ctx.restore();
        }

        function updateDifficulty() {
            // scala progressione in base alla difficolt√† selezionata
            const speedBoost = Math.min(score * 0.05 * diffScale, 1.8 * diffScale);
            obstacleSpeed = baseObstacleSpeed + speedBoost;
            // limite minimo dinamico (non meno di base-120 e non meno di 200)
            const minGap = Math.max(baseObstacleGap - 120, 200);
            obstacleGap = Math.max(minGap, baseObstacleGap - score * 2 * diffScale);
        }

        function applyDifficulty(key) {
            if (!DIFFICULTIES[key]) return;
            currentDifficulty = key;
            const cfg = DIFFICULTIES[key];
            baseObstacleGap = cfg.gap;
            baseObstacleSpeed = cfg.speed;
            gravity = cfg.gravity;
            diffScale = cfg.dynamicScale;
            obstacleGap = baseObstacleGap;
            obstacleSpeed = baseObstacleSpeed;
            // reset elementi per coerenza visiva pre-start
            resetObstacles();
            resetBottles();
            resetFlyingObstacles();
            chicoY = canvas.height / 2;
            chicoVY = 0;
            score = 0;
            gameOver = false;
            hasStarted = false;
            showHint = true;
            safeStartEndTime = 0;
            difficultyChosen = true; // abilitato avvio
            const info = document.getElementById('diffInfo');
            if (info) info.textContent = capitalizeFirst(key) + ': ' + cfg.desc + ' TAP per iniziare!';
        }
        function capitalizeFirst(s){return s.charAt(0).toUpperCase()+s.slice(1);}        

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawClouds();
                drawParallax();
            drawParticles();

            // Fase pre-avvio: scena statica con suggerimento
            if (!hasStarted && !gameOver) {
                for (let i = 0; i < obstacles.length; i++) {
                    drawObstacle(obstacles[i]);
                }
                for (let i = 0; i < bottles.length; i++) {
                    if (!bottles[i].collected) drawBottle(bottles[i]);
                }
                // Chico con lieve dondolio senza fisica
                const bob = Math.sin(Date.now() / 400) * 3;
                drawChico(chicoY + bob);
                drawHintOverlay();
                document.getElementById('score').textContent = `RUM: ${score}`;
                requestAnimationFrame(gameLoop);
                return;
            }

            updateDifficulty();
            // Possibile spawn scudo
            spawnShieldMaybe();
            // Possibile spawn pannocchia
            spawnCornMaybe();
            // Ostacoli (barili a terra/cielo)
            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                obs.x -= obstacleSpeed;
                drawObstacle(obs);
                // Collisione con il bordo del gap
                if (
                    80 + CHICO_RADIUS > obs.x &&
                    80 - CHICO_RADIUS < obs.x + OBSTACLE_WIDTH
                ) {
                    const gapSizeColl = obs.gap !== undefined ? obs.gap : obstacleGap;
                    const outGap = (chicoY - CHICO_RADIUS < obs.gapY || chicoY + CHICO_RADIUS > obs.gapY + gapSizeColl);
                    if (outGap && hasShield) {
                        consumeShieldEffect();
                    } else if (outGap && !isSafeStartActive() && Date.now() >= shieldInvulnUntil) {
                        gameOver = true;
                    }
                }
                // Punteggio solo tramite bottiglie: non incrementare qui
                obs.passed = obs.passed || (obs.x + OBSTACLE_WIDTH < 80 - CHICO_RADIUS);
            }
            // Pulisci ostacoli usciti dallo schermo
            if (obstacles.length && obstacles[0].x + OBSTACLE_WIDTH < 0) {
                obstacles.shift();
            }
            // Genera nuovi ostacoli a distanza regolare
            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 220) {
                obstacles.push(createObstacle(canvas.width + Math.random() * 120));
            }
            // Ostacoli volanti solo dopo 10 punti
            if (score >= 5) {
                for (let i = 0; i < flyingObstacles.length; i++) {
                    let obs = flyingObstacles[i];
                    const flySpeed = Math.max(obstacleSpeed * 1.15, 2.2);
                    obs.x -= flySpeed;
                    if (obs.type === 'gabbiano') {
                        obs.y += Math.sin((Date.now() + obs.x * 20) / 600) * 0.6;
                    }
                    drawFlyingObstacle(obs);
                    if (
                        80 + CHICO_RADIUS > obs.x &&
                        80 - CHICO_RADIUS < obs.x + FLYING_OBSTACLE_WIDTH &&
                        chicoY + CHICO_RADIUS > obs.y &&
                        chicoY - CHICO_RADIUS < obs.y + FLYING_OBSTACLE_HEIGHT
                    ) {
                        if (hasShield) {
                            consumeShieldEffect();
                        } else if (!isSafeStartActive() && Date.now() >= shieldInvulnUntil) {
                            gameOver = true;
                        }
                    }
                    // Nessun incremento punteggio per ostacoli volanti
                    obs.passed = true;
                }
                if (flyingObstacles.length && flyingObstacles[0].x + FLYING_OBSTACLE_WIDTH < 0) {
                    flyingObstacles.shift();
                }
                if (flyingObstacles.length === 0 || flyingObstacles[flyingObstacles.length-1].x < canvas.width - 300) {
                    flyingObstacles.push(createFlyingObstacle(canvas.width + Math.random() * 200));
                }
            }

        // Bottiglie
            for (let i = 0; i < bottles.length; i++) {
                let bottle = bottles[i];
                bottle.x -= obstacleSpeed;
                if (!bottle.collected) {
                    drawBottle(bottle);
                }
                if (!bottle.collected && Math.hypot(bottle.x - 80, bottle.y - chicoY) < CHICO_RADIUS + BOTTLE_RADIUS) {
                    score += 1;
                    bottle.collected = true;
                    spawnParticles(bottle.x, bottle.y);
                }
            }
            // Rimuovi bottiglie raccolte o uscite dallo schermo
            bottles = bottles.filter(b => !b.collected && b.x + BOTTLE_RADIUS > 0);
            // Genera nuove bottiglie in coda
            if (bottles.length === 0 || bottles[bottles.length - 1].x < canvas.width - 260) {
                bottles.push(createBottle(canvas.width + 120 + Math.random() * 120));
            }

            // Chico physics
            chicoVY += gravity;
            chicoY += chicoVY;
            drawChico(chicoY);

            if (chicoY + CHICO_RADIUS > canvas.height || chicoY - CHICO_RADIUS < 0) {
                if (hasShield) {
                    consumeShieldEffect();
                    chicoVY = chicoY + CHICO_RADIUS > canvas.height ? -6 : 4;
                } else if (!isSafeStartActive() && Date.now() >= shieldInvulnUntil) {
                    gameOver = true;
                }
                chicoY = Math.min(Math.max(chicoY, CHICO_RADIUS + 2), canvas.height - CHICO_RADIUS - 2);
            }

            // Gestione oggetti scudo
            for (let i = shieldItems.length - 1; i >= 0; i--) {
                const item = shieldItems[i];
                item.x -= obstacleSpeed * 0.9;
                if (!item.collected) drawShieldItem(item);
                if (!item.collected && Math.hypot(item.x - 80, item.y - chicoY) < CHICO_RADIUS + SHIELD_RADIUS) {
                    item.collected = true;
                    hasShield = true;
                    shieldCharges = SHIELD_HITS;
                    shieldInvulnUntil = Date.now() + 120; // breve tolleranza subito dopo raccolta
                    spawnParticles(item.x, item.y, '#8fd8ff');
                }
                if (item.collected || item.x + SHIELD_RADIUS < -12) {
                    shieldItems.splice(i,1);
                }
            }

            // Gestione pannocchie (corn)
            for (let i = cornItems.length - 1; i >= 0; i--) {
                const item = cornItems[i];
                item.x -= obstacleSpeed * 0.95;
                if (!item.collected) drawCornItem(item);
                if (!item.collected && Math.hypot(item.x - 80, item.y - chicoY) < CHICO_RADIUS + CORN_RADIUS) {
                    item.collected = true;
                    ammo = Math.min(MAX_AMMO, ammo + 1);
                    spawnParticles(item.x, item.y, '#ffe066');
                }
                if (item.collected || item.x + CORN_RADIUS < -20) {
                    cornItems.splice(i,1);
                }
            }

            // Proiettili
            updateProjectiles();

            // Aggiorna score DOM solo se cambia
            if (!window._lastScoreText || window._lastScoreText !== score) {
                document.getElementById('score').textContent = `RUM: ${score}`;
                window._lastScoreText = score;
            }
            const ammoDisp = document.getElementById('ammoDisplay');
            if (ammoDisp) ammoDisp.textContent = 'üåΩ'.repeat(ammo);
            if (!gameOver) {
                requestAnimationFrame(gameLoop);
            } else {
                // Mostra overlay e tenta anche shareScore nativo se disponibile
                telegramShareScore(score);
                showGameOverScreen(score);

                // Disegno testuale opzionale sotto l‚Äôoverlay
                ctx.font = 'bold 36px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText('Arr!', canvas.width/2, canvas.height/2);
            }
        }

        function flap() {
            // richiede prima la scelta della difficolt√†
            if (!difficultyChosen) return;
            if (!hasStarted && !gameOver) {
                hasStarted = true;
                showHint = false;
                safeStartEndTime = Date.now() + SAFE_START_DURATION;
                if (!bgm) setupBgm(MUSIC_URL);
                if (!isMuted) ensureBgmPlaying();
                chicoVY = FLAP;
                return;
            }
            if (!gameOver) {
                chicoVY = FLAP;
                // suono rimosso
            } else {
                // reset partita
                chicoY = canvas.height / 2;
                chicoVY = 0;
                score = 0;
                gameOver = false;
                hasStarted = false;
                resetClouds();
                showHint = true;
                safeStartEndTime = 0;
                resetObstacles();
                resetBottles();
                resetFlyingObstacles();
                shieldItems = [];
                hasShield = false;
                shieldCharges = 0;
                shieldBreakingEnd = 0;
                shieldInvulnUntil = 0;
                // reset shooting
                ammo = MAX_AMMO;
                projectiles = [];
                cornItems = [];
                lastCornSpawnScore = 0;
                const ammoDisp = document.getElementById('ammoDisplay');
                if (ammoDisp) ammoDisp.textContent = 'üåΩ'.repeat(ammo);
                gameLoop();
            }
        }
    resetClouds();
    // Input solo touch/mouse (mobile friendly)
    canvas.addEventListener('mousedown', flap);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); flap(); }, { passive: false });

    // Avvio: mostra hint, nessun movimento finch√© non si tocca
    resetObstacles();
    resetBottles();
    resetFlyingObstacles();
    shieldItems = [];
    hasShield = false;
    shieldCharges = 0;
    shieldBreakingEnd = 0;
    shieldInvulnUntil = 0;
    hasStarted = false;
    showHint = true;
    safeStartEndTime = 0;
    // Inizializza pulsanti UI
    document.getElementById('muteBtn').addEventListener('click', toggleMute);
    const diffOverlay = document.getElementById('difficultyOverlay');
    const diffButtonsWrap = document.getElementById('diffButtons');
    const diffInfo = document.getElementById('diffInfo');
    document.getElementById('diffGearBtn').addEventListener('click', () => {
        if (!hasStarted) {
            diffOverlay.style.display = 'flex';
        }
    });
    document.getElementById('fireBtn').addEventListener('click', fire);
    document.getElementById('fireBtn').addEventListener('touchstart', (e)=>{ e.preventDefault(); fire(); }, { passive:false });
    // Pulsanti overlay game over
    const restartBtn = document.getElementById('restartBtn');
    if (restartBtn) restartBtn.addEventListener('click', () => {
        hideGameOverScreen();
        // Usa la stessa routine di reset gi√† presente in flap() quando gameOver=true
        flap();
    });
    // Pulsante invio punteggio: lasciare la navigazione all'anchor
    const btnS = document.getElementById('sendScoreBtn');
    if (btnS) btnS.addEventListener('click', () => {
        hideGameOverScreen();
        // Navigazione gestita dall'href; in alcuni WebView iOS tg:// funziona meglio
    });
    // Opzionale: tastiera per debug
    window.addEventListener('keydown', (e)=>{
        if (e.code === 'KeyF' || e.code === 'Space' || e.key === ' ' ) {
            e.preventDefault();
            fire();
        }
    });
    diffButtonsWrap.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-diff]');
        if (!btn) return;
        [...diffButtonsWrap.querySelectorAll('button')].forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        const key = btn.getAttribute('data-diff');
        applyDifficulty(key);
        if (diffInfo) diffInfo.textContent = capitalizeFirst(key) + ': ' + DIFFICULTIES[key].desc + ' TAP per iniziare!';
        // nascondi overlay subito dopo la scelta
        diffOverlay.style.display = 'none';
    });
    // Stato iniziale: difficolt√† normale selezionata visivamente ma non confermata -> richiede scelta
    difficultyChosen = false;
    // Inizializza munizioni visualizzate
    document.getElementById('ammoDisplay').textContent = 'üåΩ'.repeat(ammo);
    gameLoop();
    </script>
</body>
</html>
